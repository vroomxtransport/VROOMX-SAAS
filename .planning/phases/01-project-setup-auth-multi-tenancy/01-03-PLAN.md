---
phase: 01-project-setup-auth-multi-tenancy
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/lib/supabase/client.ts
  - src/lib/supabase/server.ts
  - src/lib/supabase/service-role.ts
  - src/lib/supabase/proxy.ts
  - proxy.ts
autonomous: true

must_haves:
  truths:
    - "Browser Supabase client can be created in client components"
    - "Server Supabase client can be created in Server Components and Server Actions"
    - "Service role client bypasses RLS for admin operations"
    - "Auth proxy refreshes tokens on every request to protected routes"
    - "Unauthenticated users are redirected to /login from /dashboard"
    - "Authenticated users without tenant_id are redirected to /onboarding"
  artifacts:
    - path: "src/lib/supabase/client.ts"
      provides: "Browser Supabase client factory"
      exports: ["createClient"]
    - path: "src/lib/supabase/server.ts"
      provides: "Server Supabase client factory"
      exports: ["createClient"]
    - path: "src/lib/supabase/service-role.ts"
      provides: "Service role client factory"
      exports: ["createServiceRoleClient"]
    - path: "src/lib/supabase/proxy.ts"
      provides: "Session update logic for proxy"
      exports: ["updateSession"]
    - path: "proxy.ts"
      provides: "Next.js 16 proxy (replaces middleware.ts)"
      exports: ["proxy", "config"]
  key_links:
    - from: "proxy.ts"
      to: "src/lib/supabase/proxy.ts"
      via: "import updateSession"
      pattern: "import.*updateSession.*from.*@/lib/supabase/proxy"
    - from: "src/lib/supabase/server.ts"
      to: "next/headers"
      via: "async cookies()"
      pattern: "await cookies\\(\\)"
    - from: "src/lib/supabase/service-role.ts"
      to: "SUPABASE_SECRET_KEY"
      via: "env var (no NEXT_PUBLIC_ prefix)"
      pattern: "SUPABASE_SECRET_KEY"
---

<objective>
Create the three Supabase client factories (browser, server, service-role) and the Next.js 16 proxy.ts for auth session refresh. This is the auth plumbing that every page and Server Action depends on.

Purpose: Without these client factories, no component can talk to Supabase. Without the proxy, auth tokens expire and users get silently logged out.
Output: Four Supabase utility files plus the root proxy.ts that protects dashboard routes.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/PROJECT.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/ROADMAP.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/phases/01-project-setup-auth-multi-tenancy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Supabase client factories (browser, server, service-role)</name>
  <files>
    src/lib/supabase/client.ts
    src/lib/supabase/server.ts
    src/lib/supabase/service-role.ts
  </files>
  <action>
    1. Create `src/lib/supabase/client.ts` (browser client -- used in client components):
    ```typescript
    import { createBrowserClient } from '@supabase/ssr'

    export function createClient() {
      return createBrowserClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!
      )
    }
    ```
    NOTE: Uses `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY` (NOT the old `NEXT_PUBLIC_SUPABASE_ANON_KEY`). New Supabase projects created after Nov 2025 use publishable keys.

    2. Create `src/lib/supabase/server.ts` (server client -- used in Server Components, Server Actions, Route Handlers):
    ```typescript
    import { createServerClient } from '@supabase/ssr'
    import { cookies } from 'next/headers'

    export async function createClient() {
      const cookieStore = await cookies()

      return createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
        {
          cookies: {
            getAll() {
              return cookieStore.getAll()
            },
            setAll(cookiesToSet) {
              try {
                cookiesToSet.forEach(({ name, value, options }) =>
                  cookieStore.set(name, value, options)
                )
              } catch {
                // Called from Server Component where cookies can't be set.
                // This is expected -- the proxy handles cookie refresh.
              }
            },
          },
        }
      )
    }
    ```
    CRITICAL: `cookies()` is async in Next.js 16 -- must use `await cookies()`.
    CRITICAL: The try/catch in setAll is intentional. Server Components can read cookies but not set them. The proxy.ts handles cookie refresh.

    3. Create `src/lib/supabase/service-role.ts` (admin client -- NEVER import in client code):
    ```typescript
    import { createClient } from '@supabase/supabase-js'

    export function createServiceRoleClient() {
      return createClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.SUPABASE_SECRET_KEY!,
        {
          auth: {
            autoRefreshToken: false,
            persistSession: false,
          },
        }
      )
    }
    ```
    CRITICAL: Uses `SUPABASE_SECRET_KEY` (no NEXT_PUBLIC_ prefix). This key bypasses ALL RLS. Never expose it to the browser. The env var has no NEXT_PUBLIC_ prefix, so Next.js will NOT include it in the client bundle.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all three files compile.
    Verify `src/lib/supabase/client.ts` uses `NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY` (not ANON_KEY).
    Verify `src/lib/supabase/server.ts` uses `await cookies()` (async).
    Verify `src/lib/supabase/service-role.ts` uses `SUPABASE_SECRET_KEY` (no NEXT_PUBLIC_ prefix).
  </verify>
  <done>
    Three Supabase client factories created: browser (createBrowserClient), server (createServerClient with async cookies), service-role (createClient with secret key). All use correct Next.js 16 + new Supabase key naming patterns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Next.js 16 proxy.ts for auth session refresh and route protection</name>
  <files>
    src/lib/supabase/proxy.ts
    proxy.ts
  </files>
  <action>
    1. Create `src/lib/supabase/proxy.ts` (the session update logic):
    ```typescript
    import { createServerClient } from '@supabase/ssr'
    import { NextResponse, type NextRequest } from 'next/server'

    export async function updateSession(request: NextRequest) {
      let supabaseResponse = NextResponse.next({ request })

      const supabase = createServerClient(
        process.env.NEXT_PUBLIC_SUPABASE_URL!,
        process.env.NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY!,
        {
          cookies: {
            getAll() {
              return request.cookies.getAll()
            },
            setAll(cookiesToSet) {
              cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
              supabaseResponse = NextResponse.next({ request })
              cookiesToSet.forEach(({ name, value, options }) =>
                supabaseResponse.cookies.set(name, value, options)
              )
            },
          },
        }
      )

      // IMPORTANT: Use getUser(), NOT getSession()
      // getUser() validates the token server-side via Supabase Auth
      // getSession() only reads the cookie and can be spoofed
      const {
        data: { user },
      } = await supabase.auth.getUser()

      // Redirect unauthenticated users from protected routes to login
      if (
        !user &&
        request.nextUrl.pathname.startsWith('/dashboard')
      ) {
        const url = request.nextUrl.clone()
        url.pathname = '/login'
        return NextResponse.redirect(url)
      }

      // Redirect authenticated users without tenant to onboarding
      // (they signed up but haven't completed tenant creation)
      if (
        user &&
        !user.app_metadata?.tenant_id &&
        request.nextUrl.pathname.startsWith('/dashboard')
      ) {
        const url = request.nextUrl.clone()
        url.pathname = '/onboarding'
        return NextResponse.redirect(url)
      }

      // Redirect authenticated users away from auth pages
      if (
        user &&
        user.app_metadata?.tenant_id &&
        (request.nextUrl.pathname === '/login' || request.nextUrl.pathname === '/signup')
      ) {
        const url = request.nextUrl.clone()
        url.pathname = '/dashboard'
        return NextResponse.redirect(url)
      }

      // CRITICAL: Return supabaseResponse (not NextResponse.next())
      // supabaseResponse contains the updated auth cookies from setAll
      return supabaseResponse
    }
    ```

    2. Create `proxy.ts` in the project root (NOT in src/):
    ```typescript
    import { type NextRequest } from 'next/server'
    import { updateSession } from '@/lib/supabase/proxy'

    export async function proxy(request: NextRequest) {
      return await updateSession(request)
    }

    export const config = {
      matcher: [
        /*
         * Match all request paths except:
         * - _next/static (static files)
         * - _next/image (image optimization files)
         * - favicon.ico (favicon file)
         * - Static assets (svg, png, jpg, jpeg, gif, webp)
         * - /ingest (PostHog reverse proxy)
         */
        '/((?!_next/static|_next/image|favicon.ico|ingest|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)',
      ],
    }
    ```

    CRITICAL: In Next.js 16, `middleware.ts` is renamed to `proxy.ts`. The exported function is `proxy` (not `middleware`). The file MUST be at the project root (same level as package.json), NOT inside src/.

    CRITICAL: The matcher excludes `/ingest` (PostHog reverse proxy path) to avoid auth overhead on analytics requests.

    CRITICAL: Three redirect rules:
    - Unauthenticated + /dashboard -> /login (protect dashboard)
    - Authenticated + no tenant_id + /dashboard -> /onboarding (incomplete signup)
    - Authenticated + has tenant_id + /login or /signup -> /dashboard (already logged in)
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify both files compile.
    Verify `proxy.ts` exists at project root (not in src/).
    Verify `proxy.ts` exports `proxy` function (not `middleware`).
    Verify `src/lib/supabase/proxy.ts` uses `getUser()` (not `getSession()`).
    Verify the matcher excludes `/ingest` for PostHog.
  </verify>
  <done>
    Next.js 16 proxy.ts at project root with proper export name. Session refresh logic in lib/supabase/proxy.ts. Three route protection rules: unauthenticated redirect to /login, no-tenant redirect to /onboarding, already-authenticated redirect to /dashboard. Uses getUser() for server-side token validation. PostHog /ingest path excluded from proxy.
  </done>
</task>

</tasks>

<verification>
- All 5 files compile with `npx tsc --noEmit`
- Browser client uses NEXT_PUBLIC_SUPABASE_PUBLISHABLE_KEY
- Server client uses `await cookies()` (Next.js 16 async)
- Service role client uses SUPABASE_SECRET_KEY (no NEXT_PUBLIC_ prefix)
- proxy.ts at project root, exports `proxy` function
- Session refresh uses getUser() not getSession()
- Route protection: /dashboard -> /login for unauthed, /dashboard -> /onboarding for no tenant
</verification>

<success_criteria>
- Three Supabase client factories: browser, server, service-role
- proxy.ts at project root with correct Next.js 16 export
- Auth session refresh on every request
- Protected routes redirect unauthenticated users
- Incomplete signups redirect to onboarding
- Authenticated users skip login/signup pages
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-auth-multi-tenancy/01-03-SUMMARY.md`
</output>
