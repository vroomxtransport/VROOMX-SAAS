---
phase: 01-project-setup-auth-multi-tenancy
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - supabase/migrations/00001_initial_schema.sql
  - src/db/schema.ts
  - src/db/index.ts
autonomous: true

must_haves:
  truths:
    - "tenants table exists with RLS enabled and tenant isolation policies"
    - "tenant_memberships table exists with RLS and role column"
    - "stripe_events table exists for webhook idempotency"
    - "get_tenant_id() helper function uses (SELECT ...) wrapper pattern"
    - "custom_access_token_hook injects tenant_id and role into JWT"
    - "Drizzle schema mirrors the SQL schema for type-safe queries"
  artifacts:
    - path: "supabase/migrations/00001_initial_schema.sql"
      provides: "Complete SQL schema with RLS"
      contains: "CREATE TABLE public.tenants"
    - path: "src/db/schema.ts"
      provides: "Drizzle ORM schema definitions"
      contains: "pgTable"
    - path: "src/db/index.ts"
      provides: "Drizzle client initialization"
      contains: "prepare: false"
  key_links:
    - from: "src/db/schema.ts"
      to: "supabase/migrations/00001_initial_schema.sql"
      via: "Schema parity"
      pattern: "tenants|tenant_memberships|stripe_events"
    - from: "src/db/index.ts"
      to: "process.env.DATABASE_URL"
      via: "Connection string"
      pattern: "DATABASE_URL"
---

<objective>
Create the foundational database schema for multi-tenant isolation: tenants, tenant_memberships, and stripe_events tables with RLS policies using the (SELECT ...) wrapper pattern. Set up the custom access token hook for JWT tenant_id injection. Mirror the schema in Drizzle ORM for type-safe server-side queries.

Purpose: This is the security foundation. Every table in the system will follow the RLS pattern established here. The JWT hook enables all downstream auth checks.
Output: SQL migration file ready to run in Supabase Dashboard, plus Drizzle schema for server-side TypeScript queries.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/PROJECT.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/ROADMAP.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/phases/01-project-setup-auth-multi-tenancy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SQL migration with tenants, memberships, stripe_events, RLS, and auth hook</name>
  <files>supabase/migrations/00001_initial_schema.sql</files>
  <action>
    Create `supabase/migrations/00001_initial_schema.sql` with the complete initial schema. This file will be run manually in the Supabase Dashboard SQL Editor (since Supabase CLI is not installed on this machine).

    The SQL must include, in this order:

    1. **get_tenant_id() helper function** (used by all RLS policies):
    ```sql
    CREATE OR REPLACE FUNCTION public.get_tenant_id()
    RETURNS UUID AS $$
      SELECT ((auth.jwt()->'app_metadata'->>'tenant_id'))::uuid;
    $$ LANGUAGE sql STABLE;

    GRANT EXECUTE ON FUNCTION public.get_tenant_id() TO authenticated;
    ```

    2. **tenants table**:
    ```sql
    CREATE TABLE public.tenants (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      name TEXT NOT NULL,
      slug TEXT NOT NULL UNIQUE,
      plan TEXT NOT NULL DEFAULT 'trial',
      subscription_status TEXT NOT NULL DEFAULT 'trialing',
      stripe_customer_id TEXT,
      stripe_subscription_id TEXT,
      trial_ends_at TIMESTAMPTZ,
      created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
    ```

    3. **tenant_memberships table**:
    ```sql
    CREATE TABLE public.tenant_memberships (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
      user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
      role TEXT NOT NULL DEFAULT 'viewer' CHECK (role IN ('owner', 'admin', 'dispatcher', 'viewer')),
      created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
      updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
      UNIQUE(tenant_id, user_id)
    );
    ```

    4. **stripe_events table** (for webhook idempotency):
    ```sql
    CREATE TABLE public.stripe_events (
      id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
      event_id TEXT NOT NULL UNIQUE,
      event_type TEXT NOT NULL,
      processed_at TIMESTAMPTZ NOT NULL DEFAULT now()
    );
    ```

    5. **RLS policies on tenants** using (SELECT ...) wrapper:
    ```sql
    ALTER TABLE public.tenants ENABLE ROW LEVEL SECURITY;

    -- Tenants: users can only see their own tenant
    CREATE POLICY "tenant_isolation_select" ON public.tenants
      FOR SELECT TO authenticated
      USING (id = (SELECT public.get_tenant_id()));

    CREATE POLICY "tenant_isolation_update" ON public.tenants
      FOR UPDATE TO authenticated
      USING (id = (SELECT public.get_tenant_id()))
      WITH CHECK (id = (SELECT public.get_tenant_id()));
    ```
    NOTE: No INSERT policy for tenants -- new tenants are created via service role during signup. No DELETE policy -- tenants cannot self-delete.

    6. **RLS policies on tenant_memberships**:
    ```sql
    ALTER TABLE public.tenant_memberships ENABLE ROW LEVEL SECURITY;

    CREATE POLICY "tenant_isolation_select" ON public.tenant_memberships
      FOR SELECT TO authenticated
      USING (tenant_id = (SELECT public.get_tenant_id()));

    CREATE POLICY "tenant_isolation_insert" ON public.tenant_memberships
      FOR INSERT TO authenticated
      WITH CHECK (tenant_id = (SELECT public.get_tenant_id()));

    CREATE POLICY "tenant_isolation_update" ON public.tenant_memberships
      FOR UPDATE TO authenticated
      USING (tenant_id = (SELECT public.get_tenant_id()))
      WITH CHECK (tenant_id = (SELECT public.get_tenant_id()));

    CREATE POLICY "tenant_isolation_delete" ON public.tenant_memberships
      FOR DELETE TO authenticated
      USING (tenant_id = (SELECT public.get_tenant_id()));
    ```

    7. **RLS on stripe_events** -- service role only, no authenticated access:
    ```sql
    ALTER TABLE public.stripe_events ENABLE ROW LEVEL SECURITY;
    -- No policies for authenticated role. Only service_role can read/write.
    ```

    8. **Custom Access Token Hook**:
    ```sql
    CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
    AS $$
    DECLARE
      claims jsonb;
      tenant_membership RECORD;
    BEGIN
      claims := event->'claims';

      SELECT tm.tenant_id, tm.role, t.plan, t.subscription_status
      INTO tenant_membership
      FROM public.tenant_memberships tm
      JOIN public.tenants t ON t.id = tm.tenant_id
      WHERE tm.user_id = (event->>'user_id')::uuid
      ORDER BY tm.created_at ASC
      LIMIT 1;

      IF tenant_membership IS NOT NULL THEN
        claims := jsonb_set(
          claims,
          '{app_metadata}',
          COALESCE(claims->'app_metadata', '{}'::jsonb) ||
          jsonb_build_object(
            'tenant_id', tenant_membership.tenant_id,
            'role', tenant_membership.role,
            'plan', tenant_membership.plan,
            'subscription_status', tenant_membership.subscription_status
          )
        );
      END IF;

      RETURN jsonb_set(event, '{claims}', claims);
    END;
    $$;

    -- Grant to supabase_auth_admin (required for auth hooks)
    GRANT EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) TO supabase_auth_admin;
    GRANT USAGE ON SCHEMA public TO supabase_auth_admin;
    REVOKE EXECUTE ON FUNCTION public.custom_access_token_hook(jsonb) FROM authenticated, anon, public;
    GRANT SELECT ON public.tenant_memberships TO supabase_auth_admin;
    GRANT SELECT ON public.tenants TO supabase_auth_admin;
    ```

    9. **updated_at trigger** (reusable for all tables):
    ```sql
    CREATE OR REPLACE FUNCTION public.handle_updated_at()
    RETURNS TRIGGER AS $$
    BEGIN
      NEW.updated_at = now();
      RETURN NEW;
    END;
    $$ LANGUAGE plpgsql;

    CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.tenants
      FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();

    CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.tenant_memberships
      FOR EACH ROW EXECUTE FUNCTION public.handle_updated_at();
    ```

    10. **Indexes**:
    ```sql
    CREATE INDEX idx_tenant_memberships_user_id ON public.tenant_memberships(user_id);
    CREATE INDEX idx_tenant_memberships_tenant_id ON public.tenant_memberships(tenant_id);
    CREATE INDEX idx_tenants_stripe_customer_id ON public.tenants(stripe_customer_id);
    CREATE INDEX idx_stripe_events_event_id ON public.stripe_events(event_id);
    ```

    CRITICAL: Do NOT use SECURITY DEFINER on the access token hook. Use explicit GRANT to supabase_auth_admin as shown above.
    CRITICAL: Always use `(SELECT public.get_tenant_id())` with the SELECT wrapper in RLS policies for performance.
  </action>
  <verify>
    Verify the SQL file exists and contains all expected objects:
    - grep for "CREATE TABLE public.tenants"
    - grep for "CREATE TABLE public.tenant_memberships"
    - grep for "CREATE TABLE public.stripe_events"
    - grep for "get_tenant_id()"
    - grep for "custom_access_token_hook"
    - grep for "(SELECT public.get_tenant_id())" -- the performance-critical wrapper
    - grep for "ENABLE ROW LEVEL SECURITY" (should appear 3 times)
    - Verify NO occurrence of "SECURITY DEFINER"
  </verify>
  <done>
    SQL migration file contains: 3 tables (tenants, tenant_memberships, stripe_events), RLS enabled on all 3 with (SELECT ...) wrapper policies, custom access token hook with proper GRANT/REVOKE, updated_at triggers, and performance indexes. Ready to paste into Supabase Dashboard SQL Editor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Drizzle ORM schema and database client</name>
  <files>
    src/db/schema.ts
    src/db/index.ts
  </files>
  <action>
    1. Create `src/db/schema.ts` mirroring the SQL schema exactly:
    ```typescript
    import { pgTable, uuid, text, timestamp, unique, index } from 'drizzle-orm/pg-core'

    export const tenants = pgTable('tenants', {
      id: uuid('id').primaryKey().defaultRandom(),
      name: text('name').notNull(),
      slug: text('slug').notNull().unique(),
      plan: text('plan').notNull().default('trial'),
      subscriptionStatus: text('subscription_status').notNull().default('trialing'),
      stripeCustomerId: text('stripe_customer_id'),
      stripeSubscriptionId: text('stripe_subscription_id'),
      trialEndsAt: timestamp('trial_ends_at', { withTimezone: true }),
      createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
      updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
    })

    export const tenantMemberships = pgTable('tenant_memberships', {
      id: uuid('id').primaryKey().defaultRandom(),
      tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
      userId: uuid('user_id').notNull(),  // References auth.users (managed by Supabase)
      role: text('role').notNull().default('viewer'),
      createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
      updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
    }, (table) => [
      unique('tenant_memberships_tenant_user_unique').on(table.tenantId, table.userId),
      index('idx_tenant_memberships_user_id').on(table.userId),
      index('idx_tenant_memberships_tenant_id').on(table.tenantId),
    ])

    export const stripeEvents = pgTable('stripe_events', {
      id: uuid('id').primaryKey().defaultRandom(),
      eventId: text('event_id').notNull().unique(),
      eventType: text('event_type').notNull(),
      processedAt: timestamp('processed_at', { withTimezone: true }).notNull().defaultNow(),
    }, (table) => [
      index('idx_stripe_events_event_id').on(table.eventId),
    ])

    // Export types for use in application code
    export type Tenant = typeof tenants.$inferSelect
    export type NewTenant = typeof tenants.$inferInsert
    export type TenantMembership = typeof tenantMemberships.$inferSelect
    export type NewTenantMembership = typeof tenantMemberships.$inferInsert
    export type StripeEvent = typeof stripeEvents.$inferSelect
    export type NewStripeEvent = typeof stripeEvents.$inferInsert
    ```

    2. Create `src/db/index.ts` with the Drizzle client:
    ```typescript
    import { drizzle } from 'drizzle-orm/postgres-js'
    import postgres from 'postgres'
    import * as schema from './schema'

    const connectionString = process.env.DATABASE_URL!

    // Use prepare: false for Supabase PgBouncer transaction mode
    // Use max: 1 for serverless (one connection per function instance)
    const client = postgres(connectionString, {
      prepare: false,
      max: 1,
      idle_timeout: 20,
    })

    export const db = drizzle(client, { schema })
    ```

    IMPORTANT: The `prepare: false` option is REQUIRED because Supabase uses PgBouncer in transaction mode, which does not support prepared statements. Without this, you get intermittent "prepared statement already exists" errors in production.

    IMPORTANT: The `userId` field in tenantMemberships does NOT use a Drizzle `.references()` to auth.users because auth.users is a Supabase-managed table not defined in this schema. The foreign key constraint exists in the SQL migration.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify the Drizzle schema compiles without TypeScript errors.
    Verify `src/db/schema.ts` exports: tenants, tenantMemberships, stripeEvents, Tenant, NewTenant, TenantMembership, NewTenantMembership, StripeEvent, NewStripeEvent.
    Verify `src/db/index.ts` exports `db` and uses `prepare: false`.
  </verify>
  <done>
    Drizzle schema defines tenants, tenant_memberships, and stripe_events with proper types, indexes, and constraints. DB client configured with prepare: false for PgBouncer. Type inference exports available for all tables (select + insert types).
  </done>
</task>

</tasks>

<verification>
- SQL migration file contains all 3 tables with RLS
- All RLS policies use `(SELECT public.get_tenant_id())` wrapper (never bare function call)
- Custom access token hook uses GRANT (not SECURITY DEFINER)
- Drizzle schema compiles without TypeScript errors
- Drizzle schema mirrors SQL schema (same tables, columns, types)
- DB client uses `prepare: false` for PgBouncer compatibility
</verification>

<success_criteria>
- SQL migration ready to run in Supabase Dashboard SQL Editor
- 3 tables: tenants, tenant_memberships, stripe_events
- RLS enabled on all 3 tables with (SELECT ...) wrapper policies
- Custom access token hook function with proper GRANT/REVOKE
- Drizzle schema with full type inference
- Drizzle client with PgBouncer-safe config
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-auth-multi-tenancy/01-02-SUMMARY.md`
</output>
