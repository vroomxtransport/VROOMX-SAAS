---
phase: 01-project-setup-auth-multi-tenancy
plan: 06
type: execute
wave: 4
depends_on: ["01-04", "01-05"]
files_modified:
  - src/app/(auth)/signup/page.tsx
  - src/app/actions/auth.ts
  - src/app/actions/logout.ts
  - src/app/(auth)/auth-confirm/route.ts
autonomous: true

must_haves:
  truths:
    - "Full signup flow works end-to-end: form -> create user -> create tenant -> Stripe Checkout -> redirect to dashboard"
    - "Email confirmation callback route handles the Supabase auth token exchange"
    - "Logout action clears session and redirects to login"
    - "Signup form shows validation errors inline"
    - "Error states are recoverable (user can retry)"
  artifacts:
    - path: "src/app/(auth)/auth-confirm/route.ts"
      provides: "Email confirmation callback"
      exports: ["GET"]
    - path: "src/app/actions/logout.ts"
      provides: "Logout Server Action"
      exports: ["logoutAction"]
  key_links:
    - from: "src/app/(auth)/auth-confirm/route.ts"
      to: "src/lib/supabase/server.ts"
      via: "token exchange"
      pattern: "exchangeCodeForSession"
    - from: "src/app/actions/logout.ts"
      to: "src/lib/supabase/server.ts"
      via: "sign out"
      pattern: "supabase.auth.signOut"
---

<objective>
Wire the complete signup-to-dashboard flow, add email confirmation callback handling, logout action, and polish the signup form with proper error handling and loading states.

Purpose: This plan connects all the pieces from Plans 03, 04, and 05 into a working end-to-end flow. Without this wiring, the individual pieces don't compose into a usable auth system.
Output: A complete auth lifecycle: signup -> email confirm -> login -> dashboard, plus logout.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/PROJECT.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/ROADMAP.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/phases/01-project-setup-auth-multi-tenancy/01-RESEARCH.md

Prior plan outputs needed:
@.planning/phases/01-project-setup-auth-multi-tenancy/01-03-SUMMARY.md
@.planning/phases/01-project-setup-auth-multi-tenancy/01-04-SUMMARY.md
@.planning/phases/01-project-setup-auth-multi-tenancy/01-05-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email confirmation route and logout action</name>
  <files>
    src/app/(auth)/auth-confirm/route.ts
    src/app/actions/logout.ts
  </files>
  <action>
    1. Create `src/app/(auth)/auth-confirm/route.ts` -- this handles the email confirmation callback from Supabase Auth:

    When a user signs up, Supabase sends a confirmation email with a link like:
    `https://yourapp.com/auth-confirm?token_hash=xxx&type=signup`

    This route exchanges the token for a session:

    ```typescript
    import { createClient } from '@/lib/supabase/server'
    import { NextResponse } from 'next/server'
    import type { NextRequest } from 'next/server'

    export async function GET(request: NextRequest) {
      const { searchParams } = new URL(request.url)
      const token_hash = searchParams.get('token_hash')
      const type = searchParams.get('type') as 'signup' | 'recovery' | 'email' | null
      const next = searchParams.get('next') ?? '/dashboard'

      if (token_hash && type) {
        const supabase = await createClient()
        const { error } = await supabase.auth.verifyOtp({
          type,
          token_hash,
        })

        if (!error) {
          // Email confirmed -- redirect to the intended destination
          return NextResponse.redirect(new URL(next, request.url))
        }
      }

      // If verification fails, redirect to login with error
      return NextResponse.redirect(
        new URL('/login?error=' + encodeURIComponent('Email verification failed. Please try again.'), request.url)
      )
    }
    ```

    IMPORTANT: Also handle the PKCE flow (code exchange). Supabase can send either `token_hash` or `code` depending on the auth flow:

    ```typescript
    // Also handle code exchange (PKCE flow)
    const code = searchParams.get('code')
    if (code) {
      const supabase = await createClient()
      const { error } = await supabase.auth.exchangeCodeForSession(code)
      if (!error) {
        return NextResponse.redirect(new URL(next, request.url))
      }
    }
    ```

    Add both token_hash and code handling in the same route.

    2. Create `src/app/actions/logout.ts`:
    ```typescript
    'use server'

    import { createClient } from '@/lib/supabase/server'
    import { redirect } from 'next/navigation'
    import { revalidatePath } from 'next/cache'

    export async function logoutAction() {
      const supabase = await createClient()
      await supabase.auth.signOut()
      revalidatePath('/', 'layout')
      redirect('/login')
    }
    ```
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify both files compile.
    Verify auth-confirm route handles both `token_hash` and `code` params.
    Verify auth-confirm route redirects to /dashboard on success and /login on failure.
    Verify logout action calls signOut() and redirects to /login.
  </verify>
  <done>
    Email confirmation route handles both token_hash (OTP) and code (PKCE) verification flows, redirecting to /dashboard on success. Logout action signs out and redirects to /login with cache revalidation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Polish signup page with loading states and inline error handling</name>
  <files>
    src/app/(auth)/signup/page.tsx
    src/app/actions/auth.ts
  </files>
  <action>
    1. Update `src/app/(auth)/signup/page.tsx` to improve the UX:

    Convert the signup page to use `useActionState` (React 19) for form state management. This gives:
    - Loading state during form submission (button shows spinner/disabled)
    - Error state with inline error message display
    - Ability to show field-level errors from zod validation

    Structure the page as a client component ('use client') that calls the signUpAction:

    ```tsx
    'use client'

    import { useActionState } from 'react'
    import { signUpAction } from '@/app/actions/auth'
    // ... shadcn imports

    export default function SignupPage() {
      const [state, formAction, isPending] = useActionState(signUpAction, null)

      return (
        <Card>
          <CardHeader>
            <h1 className="text-2xl font-bold">VroomX</h1>
            <CardDescription>Create your account and start dispatching</CardDescription>
          </CardHeader>
          <CardContent>
            {state?.error && (
              <div className="mb-4 rounded-md bg-destructive/10 p-3 text-sm text-destructive">
                {state.error}
              </div>
            )}
            <form action={formAction} className="space-y-4">
              {/* full_name, email, password, company_name inputs */}

              {/* Plan selection -- 3 styled radio cards */}
              <div className="space-y-2">
                <Label>Select your plan</Label>
                <div className="grid gap-3">
                  {/* Starter card */}
                  {/* Pro card */}
                  {/* Enterprise card */}
                </div>
                <p className="text-xs text-muted-foreground">
                  All plans include a 14-day free trial. No charge until trial ends.
                </p>
              </div>

              <Button type="submit" className="w-full" disabled={isPending}>
                {isPending ? 'Creating account...' : 'Create account'}
              </Button>
            </form>
          </CardContent>
          <CardFooter>
            <Link href="/login">Already have an account? Sign in</Link>
          </CardFooter>
        </Card>
      )
    }
    ```

    2. Update `src/app/actions/auth.ts` to return state instead of redirecting on validation errors:

    Modify `signUpAction` signature to work with `useActionState`:
    ```typescript
    export async function signUpAction(prevState: any, formData: FormData) {
      // ... validation
      if (!parsed.success) {
        return { error: parsed.error.errors[0]?.message || 'Invalid input' }
      }
      // ... rest of signup flow
      // On success, still redirect() to Stripe Checkout
      // On Supabase/Stripe errors, return { error: message }
    }
    ```

    IMPORTANT: `useActionState` requires the action to accept `(prevState, formData)` as arguments. The first argument is the previous state returned by the action.

    IMPORTANT: `redirect()` inside a Server Action throws a special error that `useActionState` handles correctly. The Stripe Checkout redirect still works.

    IMPORTANT: For the login action, also update to accept prevState:
    ```typescript
    export async function loginAction(prevState: any, formData: FormData) {
      // ... same logic but return { error } instead of redirect on error
    }
    ```

    Similarly update the login page to use `useActionState` for consistent error handling.

    3. Style the plan selection cards. Each card should be a `<label>` wrapping a hidden radio input:
    ```tsx
    <label className={`cursor-pointer rounded-lg border-2 p-4 transition-colors ${selectedPlan === 'starter' ? 'border-primary bg-primary/5' : 'border-border'}`}>
      <input type="radio" name="plan" value="starter" className="sr-only" defaultChecked />
      <div className="font-semibold">Starter</div>
      <div className="text-2xl font-bold">$49<span className="text-sm font-normal text-muted-foreground">/mo</span></div>
      <div className="text-sm text-muted-foreground">Up to 5 trucks, 3 users</div>
    </label>
    ```

    Use React state for the selected plan visual highlight (track which radio is selected for the border color).
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all files compile.
    Start dev server and visit /signup:
    - Verify plan selection cards render with pricing
    - Verify clicking a plan card highlights it
    - Verify the "14-day free trial" note is visible
    - Verify error messages show inline (not via URL redirect)
    - Verify submit button shows "Creating account..." while pending
    Also visit /login and verify it uses the same useActionState pattern.
  </verify>
  <done>
    Signup page uses useActionState for loading/error states. Plan selection shows 3 styled radio cards with pricing and tier limits. Inline error display replaces URL-param error approach. Submit button disables with loading text during submission. Login page updated with same useActionState pattern. Both actions accept (prevState, formData) signature.
  </done>
</task>

</tasks>

<verification>
- All files compile with `npx tsc --noEmit`
- Email confirmation route at /auth-confirm handles both token_hash and code flows
- Logout action signs out and redirects to /login
- Signup page shows inline errors (not URL redirects)
- Signup page has loading state on submit button
- Plan selection cards show pricing and tier limits
- Login page uses same useActionState pattern
- Both Server Actions accept (prevState, formData) for useActionState compatibility
</verification>

<success_criteria>
- Email confirmation callback handles OTP and PKCE flows
- Logout action works
- Signup form shows validation errors inline
- Loading states prevent double-submission
- Plan selection is visual and interactive
- All auth pieces compose into a working flow: signup -> confirm email -> login -> dashboard
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-auth-multi-tenancy/01-06-SUMMARY.md`
</output>
