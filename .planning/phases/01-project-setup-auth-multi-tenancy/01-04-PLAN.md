---
phase: 01-project-setup-auth-multi-tenancy
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/(auth)/layout.tsx
  - src/app/actions/auth.ts
autonomous: true

must_haves:
  truths:
    - "User can visit /login and see email/password form"
    - "User can visit /signup and see registration form with company name and plan selection"
    - "Login form submits to a Server Action that authenticates via Supabase"
    - "Signup form submits to a Server Action that creates user + tenant + Stripe checkout"
    - "Invalid credentials show an error message on the login page"
    - "Auth pages share a centered card layout"
  artifacts:
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page UI"
      min_lines: 30
    - path: "src/app/(auth)/signup/page.tsx"
      provides: "Signup page UI with plan selection"
      min_lines: 50
    - path: "src/app/(auth)/layout.tsx"
      provides: "Auth pages layout (centered card)"
      min_lines: 10
    - path: "src/app/actions/auth.ts"
      provides: "Server Actions for login and signup"
      exports: ["loginAction", "signUpAction"]
  key_links:
    - from: "src/app/(auth)/login/page.tsx"
      to: "src/app/actions/auth.ts"
      via: "form action={loginAction}"
      pattern: "loginAction"
    - from: "src/app/(auth)/signup/page.tsx"
      to: "src/app/actions/auth.ts"
      via: "form action={signUpAction}"
      pattern: "signUpAction"
    - from: "src/app/actions/auth.ts"
      to: "src/lib/supabase/server.ts"
      via: "import createClient"
      pattern: "import.*createClient.*from.*@/lib/supabase/server"
    - from: "src/app/actions/auth.ts"
      to: "src/lib/supabase/service-role.ts"
      via: "import createServiceRoleClient"
      pattern: "import.*createServiceRoleClient.*from.*@/lib/supabase/service-role"
---

<objective>
Build the login and signup pages with their Server Actions. The login page authenticates existing users. The signup page collects email, password, company name, full name, and plan selection, then creates the user, tenant, Stripe customer, tenant membership, and redirects to Stripe Checkout.

Purpose: These are the entry points to the entire application. No user can access anything without logging in or signing up.
Output: Working /login and /signup routes with Server Actions that handle the full auth flow.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/PROJECT.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/ROADMAP.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/phases/01-project-setup-auth-multi-tenancy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth layout and login/signup page UI</name>
  <files>
    src/app/(auth)/layout.tsx
    src/app/(auth)/login/page.tsx
    src/app/(auth)/signup/page.tsx
  </files>
  <action>
    1. Create `src/app/(auth)/layout.tsx` -- a centered card layout for auth pages:
    ```tsx
    export default function AuthLayout({ children }: { children: React.ReactNode }) {
      return (
        <div className="flex min-h-screen items-center justify-center bg-background px-4">
          <div className="w-full max-w-md">
            {children}
          </div>
        </div>
      )
    }
    ```

    2. Create `src/app/(auth)/login/page.tsx`:
    - Use shadcn/ui Card, Button, Input, Label components
    - Fields: email (type="email", required), password (type="password", required)
    - Form uses `action={loginAction}` (Server Action binding)
    - Show error message if `searchParams.error` is present (redirect from Server Action on failure)
    - Link to /signup at the bottom ("Don't have an account? Sign up")
    - Display "VroomX" branding at the top of the card
    - Use `useFormStatus` from `react-dom` for a loading state on the submit button (wrap the button in a separate client component or use a client component form)

    IMPORTANT: Since this uses a Server Action via form action attribute, the page itself can be a Server Component. But for `useFormStatus`, you need a client component for the submit button. Create a small `SubmitButton` client component inline or in the same directory.

    Structure:
    ```
    <Card>
      <CardHeader>
        <h1>VroomX</h1>
        <CardDescription>Sign in to your account</CardDescription>
      </CardHeader>
      <CardContent>
        {searchParams.error && <error banner>}
        <form action={loginAction}>
          <Label>Email</Label>
          <Input name="email" type="email" required />
          <Label>Password</Label>
          <Input name="password" type="password" required />
          <SubmitButton>Sign in</SubmitButton>
        </form>
      </CardContent>
      <CardFooter>
        <Link to /signup>
      </CardFooter>
    </Card>
    ```

    3. Create `src/app/(auth)/signup/page.tsx`:
    - Use shadcn/ui Card, Button, Input, Label components
    - Fields: full_name (text, required), email (email, required), password (password, required, minLength=8), company_name (text, required)
    - Plan selection: 3 radio cards (Starter $49/mo, Pro $149/mo, Enterprise $299/mo) -- default to "starter"
    - Each plan card shows: name, price, and key limit (e.g., "Up to 5 trucks" for Starter)
    - Import `TIER_PRICING` and `TIER_LIMITS` from `@/types` for the plan cards
    - Form uses `action={signUpAction}`
    - Show error message if `searchParams.error` is present
    - Link to /login at the bottom ("Already have an account? Sign in")
    - Loading state on submit button
    - Add a note below plan selection: "All plans include a 14-day free trial"

    NOTE: The plan selection can be simple radio buttons styled as cards. Use a hidden input or radio inputs with name="plan" and values "starter", "pro", "enterprise". The signup page should be a client component ('use client') so radio button selection state works interactively. Use `useActionState` from React 19 for form submission state management instead of raw form action.

    Actually, the simpler approach: make the plan selection cards with radio inputs (no JS needed for basic radio selection), and use the native form action. The plan name is submitted as formData.get('plan'). The page can remain a Server Component with a small client component for interactive elements if needed.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify all pages compile.
    Verify `/login` page renders (start dev server, visit localhost:3000/login).
    Verify `/signup` page renders with plan selection cards.
    Verify both pages use shadcn/ui components (Card, Button, Input, Label).
  </verify>
  <done>
    Auth layout centers content. Login page has email/password form with error display and link to signup. Signup page has full_name, email, password, company_name, plan selection (3 tiers with pricing), error display, and link to login. Both use Server Action form binding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create auth Server Actions (login + signup with tenant creation + Stripe checkout)</name>
  <files>src/app/actions/auth.ts</files>
  <action>
    Create `src/app/actions/auth.ts` with two Server Actions:

    1. **loginAction(formData: FormData)**:
    ```typescript
    'use server'

    import { createClient } from '@/lib/supabase/server'
    import { redirect } from 'next/navigation'
    import { revalidatePath } from 'next/cache'

    export async function loginAction(formData: FormData) {
      const supabase = await createClient()

      const email = formData.get('email') as string
      const password = formData.get('password') as string

      const { error } = await supabase.auth.signInWithPassword({ email, password })

      if (error) {
        redirect('/login?error=' + encodeURIComponent(error.message))
      }

      revalidatePath('/', 'layout')
      redirect('/dashboard')
    }
    ```

    2. **signUpAction(formData: FormData)**:
    The full signup flow as documented in the research. Steps:
    a. Validate inputs with zod (email, password min 8 chars, company_name required, full_name required, plan must be starter|pro|enterprise)
    b. Create Supabase Auth user via `supabase.auth.signUp()`
    c. Create Stripe customer via `stripe.customers.create()`
    d. Create tenant record via service role client (with plan='trial', subscription_status='trialing', trial_ends_at = now + 14 days, stripe_customer_id)
    e. Create tenant_membership (role='owner') via service role client
    f. Set app_metadata on user via `admin.auth.admin.updateUserById()` with tenant_id, role, plan
    g. Create Stripe Checkout Session with `subscription_data.trial_period_days: 14`
    h. Redirect to Stripe Checkout URL

    On any error, redirect to `/signup?error=<message>`

    ```typescript
    import { createServiceRoleClient } from '@/lib/supabase/service-role'
    import Stripe from 'stripe'
    import { z } from 'zod'

    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!)

    const signUpSchema = z.object({
      full_name: z.string().min(1, 'Full name is required'),
      email: z.string().email('Invalid email address'),
      password: z.string().min(8, 'Password must be at least 8 characters'),
      company_name: z.string().min(1, 'Company name is required'),
      plan: z.enum(['starter', 'pro', 'enterprise']),
    })

    const PRICE_MAP: Record<string, string> = {
      starter: process.env.STRIPE_STARTER_PRICE_ID!,
      pro: process.env.STRIPE_PRO_PRICE_ID!,
      enterprise: process.env.STRIPE_ENTERPRISE_PRICE_ID!,
    }

    export async function signUpAction(formData: FormData) {
      // 1. Validate inputs
      const parsed = signUpSchema.safeParse({
        full_name: formData.get('full_name'),
        email: formData.get('email'),
        password: formData.get('password'),
        company_name: formData.get('company_name'),
        plan: formData.get('plan'),
      })

      if (!parsed.success) {
        const firstError = parsed.error.errors[0]?.message || 'Invalid input'
        redirect('/signup?error=' + encodeURIComponent(firstError))
      }

      const { full_name, email, password, company_name, plan } = parsed.data
      const supabase = await createClient()

      // 2. Create Supabase Auth user
      const { data: authData, error: authError } = await supabase.auth.signUp({
        email,
        password,
        options: {
          data: { full_name },
        },
      })

      if (authError || !authData.user) {
        redirect('/signup?error=' + encodeURIComponent(authError?.message || 'Signup failed'))
      }

      // 3. Create Stripe customer
      const customer = await stripe.customers.create({
        email,
        name: company_name,
        metadata: { supabase_user_id: authData.user.id },
      })

      // 4. Create tenant via service role (bypasses RLS)
      const admin = createServiceRoleClient()

      const { data: tenant, error: tenantError } = await admin
        .from('tenants')
        .insert({
          name: company_name,
          slug: company_name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, ''),
          plan: 'trial',
          subscription_status: 'trialing',
          stripe_customer_id: customer.id,
          trial_ends_at: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000).toISOString(),
        })
        .select()
        .single()

      if (tenantError || !tenant) {
        redirect('/signup?error=' + encodeURIComponent(tenantError?.message || 'Failed to create organization'))
      }

      // 5. Create tenant membership (owner role)
      await admin.from('tenant_memberships').insert({
        tenant_id: tenant.id,
        user_id: authData.user.id,
        role: 'owner',
      })

      // 6. Set app_metadata on user (triggers JWT update via custom hook)
      await admin.auth.admin.updateUserById(authData.user.id, {
        app_metadata: {
          tenant_id: tenant.id,
          role: 'owner',
          plan: 'trial',
        },
      })

      // 7. Create Stripe Checkout Session with 14-day trial
      const session = await stripe.checkout.sessions.create({
        customer: customer.id,
        mode: 'subscription',
        line_items: [{ price: PRICE_MAP[plan], quantity: 1 }],
        subscription_data: {
          trial_period_days: 14,
          metadata: { tenant_id: tenant.id },
        },
        success_url: `${process.env.NEXT_PUBLIC_APP_URL}/dashboard?setup=complete`,
        cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/signup?error=${encodeURIComponent('Checkout canceled')}`,
        metadata: { tenant_id: tenant.id },
      })

      // 8. Redirect to Stripe Checkout
      if (session.url) {
        redirect(session.url)
      }

      redirect('/signup?error=' + encodeURIComponent('Failed to create checkout session'))
    }
    ```

    IMPORTANT: Use `createClient` from `@/lib/supabase/server` for the initial auth signup (this runs in the user's cookie context). Use `createServiceRoleClient` for tenant/membership creation (bypasses RLS since the user doesn't have a tenant_id yet).

    IMPORTANT: The slug generation strips non-alphanumeric characters and trims leading/trailing hyphens.

    IMPORTANT: Do NOT wrap Stripe calls in try/catch that swallows errors. Let them throw so Sentry can catch them. Only redirect on known errors from Supabase.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify the Server Actions compile.
    Verify `src/app/actions/auth.ts` contains both `loginAction` and `signUpAction`.
    Verify signUpAction has all 8 steps (validate, create user, create stripe customer, create tenant, create membership, set app_metadata, create checkout session, redirect).
    Verify zod validation is used for input validation.
    Verify service role client is used for tenant creation (not the user's client).
  </verify>
  <done>
    loginAction authenticates via Supabase and redirects to /dashboard. signUpAction runs the full 8-step flow: validate with zod, create Supabase user, create Stripe customer, create tenant with 14-day trial, create owner membership, set JWT app_metadata, create Stripe Checkout Session, redirect to Stripe. Errors redirect back with error message in URL params.
  </done>
</task>

</tasks>

<verification>
- All files compile with `npx tsc --noEmit`
- /login page renders with email + password form
- /signup page renders with full_name, email, password, company_name, plan selection
- loginAction uses supabase.auth.signInWithPassword
- signUpAction runs all 8 steps in correct order
- signUpAction uses service role client for tenant creation
- signUpAction uses zod for input validation
- Both actions redirect on error with error message in URL
</verification>

<success_criteria>
- Login page at /login with working form
- Signup page at /signup with plan selection (3 tiers)
- loginAction authenticates and redirects to /dashboard
- signUpAction creates user + tenant + Stripe customer + membership + checkout session
- Error handling redirects back with user-visible error messages
- Zod validation on signup inputs
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-auth-multi-tenancy/01-04-SUMMARY.md`
</output>
