---
phase: 01-project-setup-auth-multi-tenancy
plan: 05
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/lib/stripe/config.ts
  - src/lib/stripe/webhook-handlers.ts
  - src/app/api/webhooks/stripe/route.ts
autonomous: true

must_haves:
  truths:
    - "Stripe client is initialized with the secret key"
    - "Price IDs are mapped to plan names (starter, pro, enterprise)"
    - "Stripe webhook verifies signature before processing"
    - "Webhook handler is idempotent (checks stripe_events table before processing)"
    - "checkout.session.completed links subscription to tenant"
    - "customer.subscription.updated updates tenant plan and status"
    - "customer.subscription.deleted marks tenant as canceled"
    - "invoice.payment_failed marks tenant as past_due"
  artifacts:
    - path: "src/lib/stripe/config.ts"
      provides: "Stripe client and price ID mapping"
      exports: ["stripe", "PRICE_MAP"]
    - path: "src/lib/stripe/webhook-handlers.ts"
      provides: "Webhook event handlers by type"
      exports: ["handleCheckoutCompleted", "handleSubscriptionUpdated", "handleSubscriptionDeleted", "handlePaymentFailed"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Stripe webhook API route"
      exports: ["POST"]
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/config.ts"
      via: "import stripe"
      pattern: "import.*stripe.*from.*@/lib/stripe/config"
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/webhook-handlers.ts"
      via: "import handlers"
      pattern: "import.*handle.*from.*@/lib/stripe/webhook-handlers"
    - from: "src/lib/stripe/webhook-handlers.ts"
      to: "src/lib/supabase/service-role.ts"
      via: "service role for DB writes"
      pattern: "createServiceRoleClient"
---

<objective>
Create the Stripe configuration (client init + price mapping) and the webhook handler with idempotency. The webhook handles the full subscription lifecycle: checkout completed, subscription updated/deleted, and payment failures.

Purpose: Without webhooks, Stripe events never reach the database. The tenant's plan status would be stale forever. This is the billing backbone.
Output: Stripe client config, webhook event handlers, and the /api/webhooks/stripe route.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/PROJECT.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/ROADMAP.md
@/Users/reepsy/Desktop/VROOMX_SAAS/.planning/phases/01-project-setup-auth-multi-tenancy/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Stripe configuration and webhook event handlers</name>
  <files>
    src/lib/stripe/config.ts
    src/lib/stripe/webhook-handlers.ts
  </files>
  <action>
    1. Create `src/lib/stripe/config.ts`:
    ```typescript
    import Stripe from 'stripe'

    export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
      apiVersion: '2025-01-27.acacia', // Use the latest stable API version
      typescript: true,
    })

    // Map plan names to Stripe Price IDs
    export const PRICE_MAP: Record<string, string> = {
      starter: process.env.STRIPE_STARTER_PRICE_ID!,
      pro: process.env.STRIPE_PRO_PRICE_ID!,
      enterprise: process.env.STRIPE_ENTERPRISE_PRICE_ID!,
    }

    // Reverse map: Price ID -> plan name
    export const PLAN_FROM_PRICE: Record<string, string> = Object.fromEntries(
      Object.entries(PRICE_MAP).map(([plan, priceId]) => [priceId, plan])
    )
    ```
    NOTE: Check the actual latest Stripe API version when implementing. The version string above is an example -- use whatever `stripe` npm package ships with as default. You can omit the `apiVersion` option to use the SDK default.

    2. Create `src/lib/stripe/webhook-handlers.ts` with handlers for each event type:

    ```typescript
    import Stripe from 'stripe'
    import { createServiceRoleClient } from '@/lib/supabase/service-role'
    import { PLAN_FROM_PRICE } from './config'

    /**
     * Handle checkout.session.completed
     * Links the Stripe subscription to the tenant and updates plan info.
     */
    export async function handleCheckoutCompleted(session: Stripe.Checkout.Session) {
      const supabase = createServiceRoleClient()
      const tenantId = session.metadata?.tenant_id

      if (!tenantId) {
        console.error('checkout.session.completed: missing tenant_id in metadata')
        return
      }

      // Get the subscription to read the plan
      const subscriptionId = typeof session.subscription === 'string'
        ? session.subscription
        : session.subscription?.id

      if (!subscriptionId) {
        console.error('checkout.session.completed: missing subscription ID')
        return
      }

      // Update tenant with subscription ID
      // The plan will be updated by the subscription.updated event
      const { error } = await supabase
        .from('tenants')
        .update({
          stripe_subscription_id: subscriptionId,
          subscription_status: 'trialing', // Still in trial after checkout
        })
        .eq('id', tenantId)

      if (error) {
        console.error('checkout.session.completed: failed to update tenant', error)
        throw error
      }
    }

    /**
     * Handle customer.subscription.updated
     * Updates tenant plan name and subscription status.
     */
    export async function handleSubscriptionUpdated(subscription: Stripe.Subscription) {
      const supabase = createServiceRoleClient()
      const tenantId = subscription.metadata?.tenant_id

      if (!tenantId) {
        console.error('subscription.updated: missing tenant_id in metadata')
        return
      }

      // Determine plan from price ID
      const priceId = subscription.items.data[0]?.price.id
      const plan = priceId ? (PLAN_FROM_PRICE[priceId] || 'unknown') : 'unknown'

      // Map Stripe status to our status
      const statusMap: Record<string, string> = {
        trialing: 'trialing',
        active: 'active',
        past_due: 'past_due',
        canceled: 'canceled',
        unpaid: 'unpaid',
        incomplete: 'unpaid',
        incomplete_expired: 'canceled',
        paused: 'past_due',
      }

      const subscriptionStatus = statusMap[subscription.status] || subscription.status

      const { error } = await supabase
        .from('tenants')
        .update({
          plan,
          subscription_status: subscriptionStatus,
          stripe_subscription_id: subscription.id,
        })
        .eq('id', tenantId)

      if (error) {
        console.error('subscription.updated: failed to update tenant', error)
        throw error
      }
    }

    /**
     * Handle customer.subscription.deleted
     * Marks tenant as canceled. Does NOT delete data.
     */
    export async function handleSubscriptionDeleted(subscription: Stripe.Subscription) {
      const supabase = createServiceRoleClient()
      const tenantId = subscription.metadata?.tenant_id

      if (!tenantId) {
        console.error('subscription.deleted: missing tenant_id in metadata')
        return
      }

      const { error } = await supabase
        .from('tenants')
        .update({
          subscription_status: 'canceled',
        })
        .eq('id', tenantId)

      if (error) {
        console.error('subscription.deleted: failed to update tenant', error)
        throw error
      }
    }

    /**
     * Handle invoice.payment_failed
     * Marks tenant as past_due (not immediate lockout).
     */
    export async function handlePaymentFailed(invoice: Stripe.Invoice) {
      const supabase = createServiceRoleClient()

      // Get tenant_id from subscription metadata
      const subscriptionId = typeof invoice.subscription === 'string'
        ? invoice.subscription
        : invoice.subscription?.id

      if (!subscriptionId) return

      // Look up tenant by subscription ID
      const { data: tenant } = await supabase
        .from('tenants')
        .select('id')
        .eq('stripe_subscription_id', subscriptionId)
        .single()

      if (!tenant) {
        console.error('payment_failed: no tenant found for subscription', subscriptionId)
        return
      }

      const { error } = await supabase
        .from('tenants')
        .update({ subscription_status: 'past_due' })
        .eq('id', tenant.id)

      if (error) {
        console.error('payment_failed: failed to update tenant', error)
        throw error
      }
    }
    ```

    IMPORTANT: Handlers use `createServiceRoleClient()` because webhook routes don't have a user session -- they're called by Stripe, not a browser.

    IMPORTANT: `handlePaymentFailed` looks up tenant by `stripe_subscription_id` (not metadata) because invoice events don't always carry subscription metadata. This is a common pitfall.

    IMPORTANT: Handlers throw on DB errors so the webhook route returns a 500, causing Stripe to retry. They do NOT throw on missing metadata (just log and return) since retrying won't fix missing data.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify both files compile.
    Verify `src/lib/stripe/config.ts` exports `stripe`, `PRICE_MAP`, `PLAN_FROM_PRICE`.
    Verify `src/lib/stripe/webhook-handlers.ts` exports all 4 handler functions.
    Verify handlers use `createServiceRoleClient()` (not the user's client).
  </verify>
  <done>
    Stripe config exports initialized client and bidirectional price/plan mapping. Four webhook handlers implemented: checkout completed (links subscription), subscription updated (syncs plan + status), subscription deleted (marks canceled), payment failed (marks past_due). All use service role client. DB errors throw for retry; missing metadata logs and returns.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe webhook API route with signature verification and idempotency</name>
  <files>src/app/api/webhooks/stripe/route.ts</files>
  <action>
    Create `src/app/api/webhooks/stripe/route.ts`:

    ```typescript
    import { NextResponse } from 'next/server'
    import { headers } from 'next/headers'
    import { stripe } from '@/lib/stripe/config'
    import { createServiceRoleClient } from '@/lib/supabase/service-role'
    import {
      handleCheckoutCompleted,
      handleSubscriptionUpdated,
      handleSubscriptionDeleted,
      handlePaymentFailed,
    } from '@/lib/stripe/webhook-handlers'
    import type Stripe from 'stripe'

    export async function POST(req: Request) {
      const body = await req.text()
      const headersList = await headers()
      const sig = headersList.get('stripe-signature')

      if (!sig) {
        return NextResponse.json({ error: 'Missing stripe-signature header' }, { status: 400 })
      }

      // 1. Verify webhook signature
      let event: Stripe.Event
      try {
        event = stripe.webhooks.constructEvent(
          body,
          sig,
          process.env.STRIPE_WEBHOOK_SECRET!
        )
      } catch (err) {
        console.error('Webhook signature verification failed:', err)
        return NextResponse.json({ error: 'Invalid signature' }, { status: 400 })
      }

      // 2. Idempotency check -- skip already-processed events
      const supabase = createServiceRoleClient()
      const { data: existing } = await supabase
        .from('stripe_events')
        .select('id')
        .eq('event_id', event.id)
        .single()

      if (existing) {
        return NextResponse.json({ received: true, duplicate: true })
      }

      // 3. Process based on event type
      try {
        switch (event.type) {
          case 'checkout.session.completed':
            await handleCheckoutCompleted(event.data.object as Stripe.Checkout.Session)
            break

          case 'customer.subscription.updated':
            await handleSubscriptionUpdated(event.data.object as Stripe.Subscription)
            break

          case 'customer.subscription.deleted':
            await handleSubscriptionDeleted(event.data.object as Stripe.Subscription)
            break

          case 'invoice.payment_failed':
            await handlePaymentFailed(event.data.object as Stripe.Invoice)
            break

          default:
            // Unhandled event type -- log but don't error
            console.log(`Unhandled Stripe event type: ${event.type}`)
        }

        // 4. Mark event as processed (only after successful handling)
        await supabase.from('stripe_events').insert({
          event_id: event.id,
          event_type: event.type,
          processed_at: new Date().toISOString(),
        })

        return NextResponse.json({ received: true })
      } catch (error) {
        console.error(`Webhook handler error for ${event.type}:`, error)
        // Return 500 so Stripe retries this event
        return NextResponse.json(
          { error: 'Webhook handler failed' },
          { status: 500 }
        )
      }
    }
    ```

    CRITICAL: Use `await headers()` (async in Next.js 16).

    CRITICAL: The `stripe.webhooks.constructEvent()` function handles signature verification. Do NOT hand-roll HMAC verification.

    CRITICAL: Idempotency check happens BEFORE processing. The event is marked as processed AFTER successful handling. If the handler throws, the event is NOT marked -- so Stripe will retry.

    CRITICAL: The route uses `req.text()` (not `req.json()`) because Stripe signature verification needs the raw body string.

    CRITICAL: Return 500 on handler errors so Stripe retries. Return 200 on duplicates and unhandled event types.
  </action>
  <verify>
    Run `npx tsc --noEmit` to verify the route compiles.
    Verify the route:
    - Uses `req.text()` for raw body (not `req.json()`)
    - Uses `await headers()` (Next.js 16 async)
    - Calls `stripe.webhooks.constructEvent()` for signature verification
    - Checks `stripe_events` table for idempotency before processing
    - Inserts into `stripe_events` after successful processing
    - Returns 500 on handler errors (enables Stripe retry)
    - Handles 4 event types: checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.payment_failed
  </verify>
  <done>
    Stripe webhook route at /api/webhooks/stripe with: signature verification via constructEvent(), idempotency check via stripe_events table, 4 event type handlers (checkout completed, subscription updated, subscription deleted, payment failed), proper error handling (500 for retries, 200 for duplicates/unhandled).
  </done>
</task>

</tasks>

<verification>
- All files compile with `npx tsc --noEmit`
- Stripe config exports stripe client and price maps
- 4 webhook handlers implemented and exported
- Webhook route verifies signature before processing
- Idempotency check prevents duplicate event processing
- Handler errors return 500 (Stripe retries)
- Duplicate events return 200 (Stripe stops retrying)
- Raw body used for signature verification (req.text(), not req.json())
</verification>

<success_criteria>
- Stripe client initialized with secret key
- Price IDs mapped bidirectionally to plan names
- Webhook signature verification using constructEvent()
- Idempotency via stripe_events table
- 4 lifecycle events handled: checkout completed, subscription updated, subscription deleted, payment failed
- Tenant plan/status updated in database on each event
- Proper error handling with retry semantics
</success_criteria>

<output>
After completion, create `.planning/phases/01-project-setup-auth-multi-tenancy/01-05-SUMMARY.md`
</output>
