---
phase: 07-polish-launch-prep
plan: 05
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - src/app/(dashboard)/orders/_components/csv-import-dialog.tsx
  - src/app/(dashboard)/orders/_components/order-list.tsx
  - src/app/actions/orders.ts
autonomous: true

must_haves:
  truths:
    - "User can open a CSV import dialog from the orders page"
    - "CSV file is parsed client-side with papaparse and rows are previewed"
    - "User can map CSV columns to order fields before importing"
    - "Validation errors are shown per-row before import"
    - "Successfully imported orders appear in the orders list"
  artifacts:
    - path: "src/app/(dashboard)/orders/_components/csv-import-dialog.tsx"
      provides: "Multi-step CSV import wizard component"
      min_lines: 120
    - path: "src/app/actions/orders.ts"
      provides: "batchCreateOrders server action"
      contains: "batchCreateOrders"
  key_links:
    - from: "src/app/(dashboard)/orders/_components/csv-import-dialog.tsx"
      to: "papaparse"
      via: "Client-side CSV parsing"
      pattern: "Papa\\.parse"
    - from: "src/app/(dashboard)/orders/_components/csv-import-dialog.tsx"
      to: "src/app/actions/orders.ts"
      via: "Server action for batch order creation"
      pattern: "batchCreateOrders"
---

<objective>
Build CSV order import feature (ORD-7): a multi-step dialog wizard that lets users upload a CSV file, preview data, map columns to order fields, validate rows, and batch-import orders.

Purpose: Carriers migrating from spreadsheets or other TMS tools need to bulk-import existing orders. This eliminates manual data entry for onboarding.

Output: CSVImportDialog component + batchCreateOrders server action. Accessible from orders page via "Import CSV" button.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/07-polish-launch-prep/07-RESEARCH.md

# Existing order patterns
@src/app/(dashboard)/orders/page.tsx
@src/app/(dashboard)/orders/_components/order-list.tsx
@src/app/actions/orders.ts
@src/lib/validations/order.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: batchCreateOrders server action</name>
  <files>src/app/actions/orders.ts</files>
  <action>
    Add `batchCreateOrders` to the existing orders server actions file:

    ```typescript
    export async function batchCreateOrders(orders: Array<Record<string, unknown>>) {
      const supabase = await createClient()
      const { data: { user } } = await supabase.auth.getUser()
      if (!user) return { error: 'Not authenticated', created: 0, errors: [] }

      const tenantId = user.app_metadata?.tenant_id
      if (!tenantId) return { error: 'No tenant', created: 0, errors: [] }

      const results: { created: number; errors: Array<{ row: number; error: string }> } = {
        created: 0,
        errors: [],
      }

      // Process in batches of 50 to avoid overwhelming the DB
      for (let i = 0; i < orders.length; i++) {
        const row = orders[i]
        try {
          // Validate each row with the combined order schema (or a relaxed import schema)
          // Map common field names to DB column names
          const orderData = {
            tenant_id: tenantId,
            vehicle_vin: row.vehicle_vin ?? row.vin ?? null,
            vehicle_year: row.vehicle_year ? Number(row.vehicle_year) : null,
            vehicle_make: row.vehicle_make ?? row.make ?? null,
            vehicle_model: row.vehicle_model ?? row.model ?? null,
            vehicle_color: row.vehicle_color ?? row.color ?? null,
            pickup_address: row.pickup_address ?? null,
            pickup_city: row.pickup_city ?? null,
            pickup_state: row.pickup_state ?? null,
            pickup_zip: row.pickup_zip ?? null,
            delivery_address: row.delivery_address ?? null,
            delivery_city: row.delivery_city ?? null,
            delivery_state: row.delivery_state ?? null,
            delivery_zip: row.delivery_zip ?? null,
            revenue: row.revenue ? Number(row.revenue) : 0,
            carrier_pay: row.carrier_pay ? Number(row.carrier_pay) : 0,
            payment_type: row.payment_type ?? 'cod',
            status: 'new',
          }

          const { error } = await supabase.from('orders').insert(orderData)
          if (error) {
            results.errors.push({ row: i + 1, error: error.message })
          } else {
            results.created++
          }
        } catch (err) {
          results.errors.push({ row: i + 1, error: err instanceof Error ? err.message : 'Unknown error' })
        }
      }

      revalidatePath('/orders')
      return results
    }
    ```

    Key design:
    - Accept pre-mapped rows (column mapping happens on the client)
    - Insert one at a time for per-row error reporting (batch insert would fail entirely on one bad row)
    - Return { created, errors[] } for progress reporting
    - Revalidate orders path after all inserts
    - tenant_id injected server-side (never trust client)
    - Status defaults to 'new' for all imported orders
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - batchCreateOrders is exported from orders.ts
  </verify>
  <done>
    batchCreateOrders server action accepts array of mapped row objects, validates per-row, inserts with tenant_id from JWT, returns created count and per-row error array.
  </done>
</task>

<task type="auto">
  <name>Task 2: CSV import dialog component + wire to orders page</name>
  <files>
    src/app/(dashboard)/orders/_components/csv-import-dialog.tsx
    src/app/(dashboard)/orders/_components/order-list.tsx
  </files>
  <action>
    Create `src/app/(dashboard)/orders/_components/csv-import-dialog.tsx`:

    A 'use client' multi-step dialog component with 4 steps:

    **Step 1: Upload**
    - File input accepting .csv files
    - Parse file with papaparse: `Papa.parse(file, { header: true, skipEmptyLines: true })`
    - Show error if parse fails or file is empty
    - Store parsed data and headers in state
    - Show preview: "{N} rows found with {M} columns"

    **Step 2: Map Columns**
    - Display a mapping table: each order field has a Select dropdown of CSV headers
    - Order fields to map (with required flag):
      - pickup_city (required), pickup_state (required)
      - delivery_city (required), delivery_state (required)
      - vehicle_vin, vehicle_year, vehicle_make, vehicle_model, vehicle_color
      - pickup_address, pickup_zip, delivery_address, delivery_zip
      - revenue, carrier_pay, payment_type
    - Auto-map: Try to match CSV headers to order fields by fuzzy name matching (lowercase, strip underscores/spaces). E.g., "Pickup City" matches pickup_city, "VIN" matches vehicle_vin.
    - "Skip" option for columns not present in CSV
    - Validate: at minimum pickup_city + pickup_state + delivery_city + delivery_state must be mapped

    **Step 3: Preview & Validate**
    - Show a Table with first 10 mapped rows
    - Run client-side validation: check required fields are non-empty, numeric fields are valid numbers
    - Show row count: "X of Y rows valid"
    - Highlight invalid rows with red background
    - Allow user to proceed with valid rows only (skip invalid)

    **Step 4: Import**
    - Call batchCreateOrders with the mapped, validated rows
    - Show progress: "Importing... {created}/{total}"
    - On complete: show summary "Created {N} orders. {M} errors."
    - If errors: show expandable error list with row numbers
    - "Close" button closes dialog and the orders list auto-refreshes (TanStack Query invalidation)

    Wire to orders page:
    - In `order-list.tsx` (or `page.tsx`), add an "Import CSV" button next to the "Add Order" button
    - Button opens CSVImportDialog
    - Use Dialog component from shadcn/ui

    Component structure:
    ```tsx
    const [step, setStep] = useState<'upload' | 'map' | 'preview' | 'import'>('upload')
    const [file, setFile] = useState<File | null>(null)
    const [parsedData, setParsedData] = useState<Record<string, string>[]>([])
    const [headers, setHeaders] = useState<string[]>([])
    const [mapping, setMapping] = useState<Record<string, string>>({})
    const [importResult, setImportResult] = useState<{ created: number; errors: ... } | null>(null)
    ```

    Use shadcn/ui: Dialog, DialogContent, DialogHeader, DialogTitle, Button, Select, Table, Badge, Input
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - CSVImportDialog component exists with 4-step flow
    - Orders page/list has "Import CSV" button
    - papaparse is imported and used for client-side parsing
  </verify>
  <done>
    CSV import dialog with upload -> map -> preview -> import flow. Auto-maps common column names. Shows validation errors per-row. Imports valid rows via batchCreateOrders. Accessible from orders page "Import CSV" button.
  </done>
</task>

</tasks>

<verification>
- "Import CSV" button visible on orders page
- Clicking it opens 4-step dialog
- Uploading a CSV parses and shows row count
- Column mapping UI with auto-detection
- Preview shows first 10 rows with validation highlights
- Import calls batchCreateOrders and shows progress/results
- `npx tsc --noEmit` passes
</verification>

<success_criteria>
A dispatcher can upload a CSV file of orders, map columns to order fields, preview the data, and batch-import valid rows. Invalid rows are reported with error details. Imported orders appear in the orders list.
</success_criteria>

<output>
After completion, create `.planning/phases/07-polish-launch-prep/07-05-SUMMARY.md`
</output>
