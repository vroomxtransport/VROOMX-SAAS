---
phase: 06-ios-driver-app
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - VroomXDriver/Core/DataManager.swift
  - VroomXDriver/Core/PendingActionsQueue.swift
  - VroomXDriver/Core/InspectionUploadQueue.swift
  - VroomXDriver/Views/Shared/OfflineBanner.swift
  - VroomXDriver/Views/Shared/ErrorBannerView.swift
  - VroomXDriver/Views/Shared/LoadingView.swift
autonomous: true

must_haves:
  truths:
    - "App can fetch trips, orders, and expenses for the current driver from Supabase"
    - "Data is cached locally for offline access"
    - "Realtime subscriptions update trip and order data when changes happen on the server"
    - "Mutations queued when offline and synced on reconnect"
    - "Inspection media uploads retry with exponential backoff"
  artifacts:
    - path: "VroomXDriver/Core/DataManager.swift"
      provides: "Data fetching, caching, Realtime subscriptions, and mutation methods"
      contains: "fetchTrips"
    - path: "VroomXDriver/Core/PendingActionsQueue.swift"
      provides: "Offline mutation queue with sync on reconnect"
      contains: "PendingActionsQueue"
    - path: "VroomXDriver/Core/InspectionUploadQueue.swift"
      provides: "Actor-based media upload queue with exponential backoff retry"
      contains: "InspectionUploadQueue"
  key_links:
    - from: "VroomXDriver/Core/DataManager.swift"
      to: "VroomXDriver/Core/SupabaseManager.swift"
      via: "Supabase client for queries and realtime"
      pattern: "SupabaseManager\\.shared\\.client"
    - from: "VroomXDriver/Core/DataManager.swift"
      to: "VroomXDriver/Core/CacheManager.swift"
      via: "Cache trips/orders/expenses for offline"
      pattern: "CacheManager\\.shared"
    - from: "VroomXDriver/Core/PendingActionsQueue.swift"
      to: "VroomXDriver/Core/NetworkMonitor.swift"
      via: "Process queue when network reconnects"
      pattern: "NetworkMonitor"
---

<objective>
Build the data layer: fetching, caching, Realtime subscriptions, offline mutation queue, media upload queue, and shared UI components.

Purpose: Every screen needs data. This plan creates the centralized data manager that fetches from Supabase, caches locally, subscribes to Realtime updates, and handles offline mutations. Also creates shared UI components used across multiple views.

Output: DataManager, PendingActionsQueue, InspectionUploadQueue, shared UI components
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@.planning/phases/06-ios-driver-app/06-RESEARCH.md
@.planning/phases/06-ios-driver-app/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build DataManager with fetch, cache, Realtime, and mutations</name>
  <files>VroomXDriver/Core/DataManager.swift</files>
  <action>
Create `DataManager: ObservableObject` with `static let shared`:

**Published state:**
- `trips: [VroomXTrip] = []`
- `orders: [VroomXOrder] = []`
- `expenses: [VroomXExpense] = []`
- `notifications: [DriverNotification] = []`
- `isLoading: Bool = false`

**Private state:**
- `driverId: String?` — set after auth, used for all queries
- `realtimeChannel: RealtimeChannelV2?`

**Setup:**
- `configure(driverId: String)` — store driverId, start data fetch, start Realtime
- `teardown()` — unsubscribe Realtime, clear published state

**Fetch methods (all async, use Supabase SDK PostgREST):**
- `fetchTrips() async` — query trips where driver_id = driverId, ordered by start_date desc. RLS filters by tenant automatically. Cache result via CacheManager.
- `fetchOrders() async` — query orders where driver_id = driverId, ordered by created_at desc. Cache result.
- `fetchOrdersForTrip(tripId: String) async -> [VroomXOrder]` — query orders where trip_id = tripId
- `fetchExpenses(tripId: String) async -> [VroomXExpense]` — query trip_expenses where trip_id
- `fetchNotifications() async` — query driver_notifications where driver_id = driverId, ordered by created_at desc

**Mutation methods:**
- `updateOrderStatus(orderId: String, status: OrderStatus) async throws` — update orders set status, also set actual_pickup_date/actual_delivery_date timestamps as appropriate
- `submitETA(orderId: String, pickupETA: Date?, deliveryETA: Date?) async throws` — update pickup_eta/delivery_eta
- `createExpense(_ expense: ExpenseCreate) async throws` — insert into trip_expenses
- `deleteExpense(id: String) async throws` — delete from trip_expenses
- `markNotificationRead(id: String) async throws` — update driver_notifications set read_at = now

**Offline-aware mutations:**
- Before each mutation, check NetworkMonitor.shared.isConnected
- If offline, queue the mutation via PendingActionsQueue and return optimistically
- If online, execute directly

**Realtime subscriptions:**
- `startRealtime()` — subscribe to channel "driver-updates":
  - Listen to orders table changes (INSERT, UPDATE, DELETE) where driver_id matches
  - Listen to trips table changes where driver_id matches
  - Listen to driver_notifications table changes where driver_id matches
  - On each change: re-fetch the relevant data set
- `stopRealtime()` — unsubscribe from channel

**Cache integration:**
- After each successful fetch, save to CacheManager
- On initial load, if fetch fails (offline), load from CacheManager
- Pattern: try fetch from server -> cache result. On error -> load from cache -> set data.
  </action>
  <verify>DataManager has fetch methods for trips, orders, expenses, notifications. Mutations check network state. Realtime subscriptions configured for orders, trips, notifications tables.</verify>
  <done>Centralized data manager handles all Supabase queries, caching, Realtime subscriptions, and offline-aware mutations</done>
</task>

<task type="auto">
  <name>Task 2: Build offline queues and shared UI components</name>
  <files>
    VroomXDriver/Core/PendingActionsQueue.swift
    VroomXDriver/Core/InspectionUploadQueue.swift
    VroomXDriver/Views/Shared/OfflineBanner.swift
    VroomXDriver/Views/Shared/ErrorBannerView.swift
    VroomXDriver/Views/Shared/LoadingView.swift
  </files>
  <action>
**PendingActionsQueue.swift:**
- Swift `actor` for thread safety
- `static let shared = PendingActionsQueue()`
- Struct `PendingAction: Codable, Identifiable` with: id (UUID), actionType (String), payload (Data — encoded JSON), createdAt (Date), attempts (Int), lastError (String?)
- `enqueue(_ action: PendingAction)` — add to queue, persist to UserDefaults
- `processQueue() async` — iterate pending actions, execute each via DataManager, remove on success, increment attempts on failure
- `clearQueue()` — remove all pending actions (called on logout)
- Persist queue to UserDefaults so it survives app restarts
- Listen to NetworkMonitor — when connection restored, process queue automatically
- Max 5 retry attempts per action, then mark as permanently failed

**InspectionUploadQueue.swift:**
- Swift `actor` for thread safety (adapted from Horizon Star pattern)
- `static let shared = InspectionUploadQueue()`
- Struct `UploadItem: Codable, Identifiable` with: id (String UUID), inspectionId (String UUID), mediaKind (photo/video), slotKey (String), localPath (String), mimeType (String), byteSize (Int), attempts (Int), status (pending/uploading/failed), lastError (String?), nextRetryAt (Date?)
- `enqueue(_ item: UploadItem)` — add to upload queue
- `processNext() async` — take next ready item, upload to Supabase Storage, update inspection_photos/inspection_videos record with storage_path, mark completed on success
- Exponential backoff on failure: 5s, 10s, 20s, 40s, 80s... capped at 15 minutes (matching Horizon pattern)
- Storage path format: `{tenantId}/{inspectionId}/photos/{photoType}.jpg` or `.../videos/walkthrough.mp4`
- Background processing loop that runs while items exist in queue
- `clearQueue()` — called on logout

**OfflineBanner.swift:**
- Simple banner view: yellow/amber background with wifi.slash SF Symbol
- Text: "You're offline -- showing cached data"
- Shows when NetworkMonitor.isConnected == false
- Animates in/out with slide transition
- Sits at top of screen (use .overlay or .safeAreaInset)

**ErrorBannerView.swift:**
- Red-tinted banner with exclamationmark.triangle SF Symbol
- Takes `message: String` and optional `retryAction: (() -> Void)?`
- "Retry" button if retryAction provided
- Dismissable with X button

**LoadingView.swift:**
- Centered ProgressView with VroomX branding
- Optional `message: String` parameter shown below spinner
- Uses brandPrimary color tint
  </action>
  <verify>
    - PendingActionsQueue persists to UserDefaults and processes on reconnect
    - InspectionUploadQueue uses exponential backoff (5s -> 10s -> 20s)
    - OfflineBanner shows when NetworkMonitor.isConnected == false
    - All shared components use VroomX theme colors
  </verify>
  <done>Offline queues handle mutations and media uploads when disconnected; shared UI components provide consistent loading, error, and offline states across the app</done>
</task>

</tasks>

<verification>
- DataManager fetches from Supabase with RLS (no tenant_id in queries)
- Cache-first pattern: fetch -> cache -> on error load from cache
- PendingActionsQueue processes when network reconnects
- InspectionUploadQueue matches Horizon's proven exponential backoff pattern
- OfflineBanner visible when offline
- All components use VroomX theme
</verification>

<success_criteria>
- Data layer provides trips, orders, expenses, and notifications to all views
- Realtime keeps data fresh when online
- Offline mutations are queued and synced on reconnect
- Media uploads retry automatically with exponential backoff
- Shared UI components available for all subsequent view plans
</success_criteria>

<output>
After completion, create `.planning/phases/06-ios-driver-app/06-04-SUMMARY.md`
</output>
