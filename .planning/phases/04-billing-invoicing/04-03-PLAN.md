---
phase: 04-billing-invoicing
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/app/actions/payments.ts
  - src/lib/queries/payments.ts
  - src/lib/queries/receivables.ts
  - src/hooks/use-payments.ts
autonomous: true

must_haves:
  truths:
    - "Recording a payment updates order amount_paid and auto-transitions payment_status"
    - "Batch mark-paid applies a single payment date to multiple selected orders"
    - "Receivables query aggregates unpaid/invoiced orders grouped by broker"
    - "Aging buckets are computed from invoice_date using differenceInDays"
  artifacts:
    - path: "src/app/actions/payments.ts"
      provides: "Server actions for recording payments and batch operations"
      exports: ["recordPayment", "batchMarkPaid"]
    - path: "src/lib/queries/payments.ts"
      provides: "Payment fetch queries for order detail"
      exports: ["fetchPaymentsByOrder"]
    - path: "src/lib/queries/receivables.ts"
      provides: "Broker receivables aggregation and aging bucket computation"
      exports: ["fetchBrokerReceivables", "fetchAgingAnalysis"]
    - path: "src/hooks/use-payments.ts"
      provides: "TanStack Query hooks for payments with Realtime"
      exports: ["usePaymentsByOrder"]
  key_links:
    - from: "src/app/actions/payments.ts"
      to: "src/lib/validations/payment.ts"
      via: "Zod validation of payment input"
      pattern: "recordPaymentSchema\\.safeParse"
    - from: "src/app/actions/payments.ts"
      to: "orders table"
      via: "Updates amount_paid and payment_status after inserting payment"
      pattern: "payment_status.*amount_paid"
    - from: "src/lib/queries/receivables.ts"
      to: "orders and brokers tables"
      via: "Aggregation query grouping by broker"
      pattern: "broker:brokers"
---

<objective>
Build the payment data layer: server actions for recording payments (single and batch), query functions for fetching payments and computing receivables/aging, and TanStack Query hooks with Realtime subscriptions.

Purpose: This creates the data operations that the order detail billing section (Plan 04) and the billing page (Plan 05) will consume. Runs in parallel with Plan 02 (invoice generation).

Output: Server actions for payment recording, query modules for payments and receivables, and React hooks for the UI layer.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-billing-invoicing/04-CONTEXT.md
@.planning/phases/04-billing-invoicing/04-RESEARCH.md
@.planning/phases/04-billing-invoicing/04-01-SUMMARY.md
@src/app/actions/orders.ts
@src/lib/queries/orders.ts
@src/hooks/use-orders.ts
@src/lib/validations/payment.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create payment server actions</name>
  <files>
    src/app/actions/payments.ts
  </files>
  <action>
    Create `src/app/actions/payments.ts` with `'use server'` directive. Follow the exact pattern from `src/app/actions/orders.ts` for auth/tenant checks.

    **Action 1: `recordPayment(orderId: string, data: unknown)`**

    1. Validate input with `recordPaymentSchema.safeParse(data)`. Return field errors on failure.
    2. Auth check: `supabase.auth.getUser()`, extract `tenant_id` from `app_metadata`.
    3. Fetch the order to get current `carrier_pay` and `amount_paid`:
       ```typescript
       const { data: order } = await supabase
         .from('orders')
         .select('carrier_pay, amount_paid, payment_status')
         .eq('id', orderId)
         .single()
       ```
    4. Validate: payment amount must not exceed remaining balance.
       ```typescript
       const carrierPay = parseFloat(order.carrier_pay)
       const currentPaid = parseFloat(order.amount_paid)
       const remaining = carrierPay - currentPaid
       if (parsed.data.amount > remaining + 0.01) {
         return { error: 'Payment amount exceeds remaining balance' }
       }
       ```
    5. Insert payment into payments table:
       ```typescript
       const { data: payment, error } = await supabase
         .from('payments')
         .insert({
           tenant_id: tenantId,
           order_id: orderId,
           amount: String(parsed.data.amount),
           payment_date: parsed.data.paymentDate,
           notes: parsed.data.notes || null,
         })
         .select()
         .single()
       ```
    6. Calculate new total paid: `currentPaid + parsed.data.amount`
    7. Determine new payment_status:
       - If `newTotalPaid >= carrierPay` (use threshold: `Math.abs(carrierPay - newTotalPaid) < 0.01`): `'paid'`
       - Else if `newTotalPaid > 0`: `'partially_paid'`
       - Else: keep current status
    8. Update order: `{ amount_paid: String(newTotalPaid), payment_status: newPaymentStatus }`
    9. `revalidatePath('/orders/' + orderId)` and `revalidatePath('/billing')`
    10. Return `{ data: payment }`

    **Action 2: `batchMarkPaid(orderIds: string[], paymentDate: string)`**

    1. Validate: `orderIds` must be non-empty array, `paymentDate` must be non-empty string.
    2. Auth check (same pattern).
    3. For each orderId:
       - Fetch order (`carrier_pay`, `amount_paid`)
       - Calculate remaining: `carrierPay - currentPaid`
       - If remaining > 0: insert payment for the remaining amount with the given date
       - Update order: `{ amount_paid: String(carrierPay), payment_status: 'paid' }`
    4. Use `Promise.allSettled()` to handle partial failures.
    5. `revalidatePath('/billing')` and `revalidatePath('/orders')`
    6. Return `{ success: true, processed: results.filter(r => r.status === 'fulfilled').length, total: orderIds.length }`
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `grep 'recordPayment' src/app/actions/payments.ts` returns match
    - `grep 'batchMarkPaid' src/app/actions/payments.ts` returns match
    - File has `'use server'` directive at top
    - File validates payment amount doesn't exceed remaining balance
    - File auto-transitions payment_status based on total paid vs carrier_pay
  </verify>
  <done>recordPayment inserts a payment, updates order amount_paid, and auto-transitions payment_status (unpaid -> partially_paid -> paid). batchMarkPaid pays remaining balance on multiple orders in one operation. Both revalidate /billing and /orders paths.</done>
</task>

<task type="auto">
  <name>Task 2: Create payment queries, receivables queries, and hooks</name>
  <files>
    src/lib/queries/payments.ts
    src/lib/queries/receivables.ts
    src/hooks/use-payments.ts
  </files>
  <action>
    **Step 1: Create `src/lib/queries/payments.ts`**

    Follow the pattern from `src/lib/queries/orders.ts`.

    ```typescript
    export async function fetchPaymentsByOrder(
      supabase: SupabaseClient,
      orderId: string
    ): Promise<Payment[]> {
      const { data, error } = await supabase
        .from('payments')
        .select('*')
        .eq('order_id', orderId)
        .order('payment_date', { ascending: false })

      if (error) throw error
      return (data ?? []) as Payment[]
    }
    ```

    Import `Payment` from `@/types/database`.

    **Step 2: Create `src/lib/queries/receivables.ts`**

    This module provides two main query functions:

    **Function 1: `fetchBrokerReceivables(supabase: SupabaseClient)`**

    1. Fetch all orders with payment_status in ['invoiced', 'partially_paid'] that have a broker:
       ```typescript
       const { data: orders, error } = await supabase
         .from('orders')
         .select('id, order_number, broker_id, carrier_pay, amount_paid, payment_status, invoice_date, broker:brokers(id, name, email)')
         .in('payment_status', ['invoiced', 'partially_paid'])
         .not('broker_id', 'is', null)
       ```
    2. Group by broker and compute aggregations into `BrokerReceivable` objects:
       ```typescript
       export interface BrokerReceivable {
         brokerId: string
         brokerName: string
         brokerEmail: string | null
         totalOwed: number        // sum of (carrier_pay - amount_paid) for unpaid orders
         invoiceCount: number     // count of orders
         oldestUnpaid: string | null  // earliest invoice_date
         paidThisMonth: number    // sum of payments in current month (optional: compute from orders with status='paid' and recent payment)
         overdueAmount: number    // sum where invoice_date > 30 days ago
         orders: Array<{ id: string; orderNumber: string | null; carrierPay: number; amountPaid: number; paymentStatus: string; invoiceDate: string | null }>
       }
       ```
    3. For `paidThisMonth`: run a **separate query** fetching orders with `payment_status = 'paid'` that have `updated_at >= startOfMonth`:
       ```typescript
       const startOfMonth = new Date()
       startOfMonth.setDate(1)
       startOfMonth.setHours(0,0,0,0)

       const { data: paidOrders } = await supabase
         .from('orders')
         .select('broker_id, amount_paid')
         .eq('payment_status', 'paid')
         .gte('updated_at', startOfMonth.toISOString())
         .not('broker_id', 'is', null)
       ```
       Then group `paidOrders` by `broker_id` and sum `amount_paid` to compute each broker's `paidThisMonth` value. Merge into the `BrokerReceivable` objects by matching `brokerId`. This is a separate query (not mixed into the receivables query) to keep the receivables query focused on outstanding invoices only.
    4. Return `BrokerReceivable[]` sorted by `totalOwed` descending.

    **Function 2: `fetchAgingAnalysis(supabase: SupabaseClient)`**

    1. Fetch all orders with payment_status in ['invoiced', 'partially_paid'] that have invoice_date set:
       ```typescript
       const { data: orders } = await supabase
         .from('orders')
         .select('id, order_number, broker_id, carrier_pay, amount_paid, invoice_date, broker:brokers(id, name)')
         .in('payment_status', ['invoiced', 'partially_paid'])
         .not('invoice_date', 'is', null)
       ```
    2. Use `differenceInDays` from `date-fns` to bucket each order:
       ```typescript
       function getAgingBucket(invoiceDate: string): 'current' | '1_30' | '31_60' | '61_90' | '90_plus' {
         const days = differenceInDays(new Date(), new Date(invoiceDate))
         if (days <= 0) return 'current'
         if (days <= 30) return '1_30'
         if (days <= 60) return '31_60'
         if (days <= 90) return '61_90'
         return '90_plus'
       }
       ```
    3. Group by broker, sum remaining amounts (carrier_pay - amount_paid) per bucket:
       ```typescript
       export interface AgingRow {
         brokerId: string
         brokerName: string
         current: number
         days1_30: number
         days31_60: number
         days61_90: number
         days90_plus: number
         total: number
       }
       ```
    4. Return `AgingRow[]` sorted by total descending.

    **Also export:** `fetchCollectionRate(supabase: SupabaseClient)` that computes:
    - Total invoiced: sum of carrier_pay for orders where payment_status in ['invoiced', 'partially_paid', 'paid']
    - Total collected: sum of amount_paid for same orders
    - Rate: (collected / invoiced) * 100
    ```typescript
    export interface CollectionRate {
      totalInvoiced: number
      totalCollected: number
      rate: number  // percentage 0-100
    }
    ```

    **Step 3: Create `src/hooks/use-payments.ts`**

    Follow the pattern from `src/hooks/use-orders.ts` with TanStack Query + Supabase Realtime.

    ```typescript
    export function usePaymentsByOrder(orderId: string) {
      // TanStack Query with queryKey ['payments', orderId]
      // Supabase Realtime subscription on 'payments' table filtered by order_id
      // Invalidate query on INSERT/UPDATE/DELETE events
    }
    ```

    Use `createBrowserClient()` from `@/lib/supabase/browser` for the Realtime channel. Subscribe to `postgres_changes` on the payments table with filter `order_id=eq.${orderId}`.

    Invalidate both `['payments', orderId]` and `['orders', orderId]` on payment changes (since payment changes affect order amount_paid/payment_status).
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `grep 'fetchPaymentsByOrder' src/lib/queries/payments.ts` returns match
    - `grep 'fetchBrokerReceivables' src/lib/queries/receivables.ts` returns match
    - `grep 'fetchAgingAnalysis' src/lib/queries/receivables.ts` returns match
    - `grep 'fetchCollectionRate' src/lib/queries/receivables.ts` returns match
    - `grep 'usePaymentsByOrder' src/hooks/use-payments.ts` returns match
    - Realtime subscription present in use-payments.ts
  </verify>
  <done>Payment queries fetch payments per order. Receivables queries aggregate by broker with total owed, invoice count, oldest unpaid, paid this month, and overdue amounts. Aging analysis buckets orders by invoice_date into current/1-30/31-60/61-90/90+ day columns per broker. Collection rate computes % of invoiced amount collected. Hook provides Realtime-enabled payment data.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Server actions validate inputs and handle auth
- Payment recording auto-transitions payment_status correctly
- Batch mark-paid handles partial failures gracefully
- Receivables and aging queries return properly typed results
- Hook subscribes to Realtime changes on payments table
</verification>

<success_criteria>
- recordPayment validates amount, inserts payment, updates order amount_paid, auto-transitions status
- batchMarkPaid pays remaining balance on multiple orders
- fetchBrokerReceivables returns per-broker aggregation of outstanding invoices
- fetchAgingAnalysis returns bucket breakdown per broker
- fetchCollectionRate returns overall collection percentage
- usePaymentsByOrder provides live-updating payment list
</success_criteria>

<output>
After completion, create `.planning/phases/04-billing-invoicing/04-03-SUMMARY.md`
</output>
