---
phase: 04-billing-invoicing
plan: 04
type: execute
wave: 3
depends_on: ["04-02", "04-03"]
files_modified:
  - src/app/(dashboard)/orders/_components/payment-recorder.tsx
  - src/app/(dashboard)/orders/_components/invoice-button.tsx
  - src/app/(dashboard)/orders/_components/order-detail.tsx
  - src/lib/queries/orders.ts
autonomous: true

must_haves:
  truths:
    - "Dispatcher can record a payment with amount and date on the order detail page"
    - "Dispatcher can send an invoice to the broker with one click from order detail"
    - "Payment status badge displays on the order detail page"
    - "Payment history shows all recorded payments with dates and amounts"
    - "Remaining balance updates after each payment"
  artifacts:
    - path: "src/app/(dashboard)/orders/_components/payment-recorder.tsx"
      provides: "Inline payment recording form with amount, date, notes"
      contains: "PaymentRecorder"
    - path: "src/app/(dashboard)/orders/_components/invoice-button.tsx"
      provides: "Send Invoice button with download PDF option"
      contains: "InvoiceButton"
    - path: "src/app/(dashboard)/orders/_components/order-detail.tsx"
      provides: "Updated order detail with billing section"
      contains: "PaymentRecorder"
  key_links:
    - from: "src/app/(dashboard)/orders/_components/payment-recorder.tsx"
      to: "src/app/actions/payments.ts"
      via: "recordPayment server action call"
      pattern: "recordPayment"
    - from: "src/app/(dashboard)/orders/_components/invoice-button.tsx"
      to: "/api/invoices/[orderId]/send"
      via: "fetch POST to send invoice"
      pattern: "api/invoices.*send"
    - from: "src/app/(dashboard)/orders/_components/order-detail.tsx"
      to: "src/app/(dashboard)/orders/_components/payment-recorder.tsx"
      via: "Component composition in billing section"
      pattern: "PaymentRecorder"
---

<objective>
Add billing functionality to the order detail page: payment recording form, send invoice button, payment status display, and payment history list.

Purpose: This is where dispatchers interact with billing on a per-order basis — recording payments, sending invoices, and seeing financial status. It connects the invoice pipeline (Plan 02) and payment data layer (Plan 03) to the existing order detail UI.

Output: Two new components (PaymentRecorder, InvoiceButton) and an updated order detail page with a billing section.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-billing-invoicing/04-CONTEXT.md
@.planning/phases/04-billing-invoicing/04-RESEARCH.md
@.planning/phases/04-billing-invoicing/04-02-SUMMARY.md
@.planning/phases/04-billing-invoicing/04-03-SUMMARY.md
@src/app/(dashboard)/orders/_components/order-detail.tsx
@src/hooks/use-payments.ts
@src/app/actions/payments.ts
@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PaymentRecorder and InvoiceButton components</name>
  <files>
    src/app/(dashboard)/orders/_components/payment-recorder.tsx
    src/app/(dashboard)/orders/_components/invoice-button.tsx
  </files>
  <action>
    **Step 1: Create `src/app/(dashboard)/orders/_components/payment-recorder.tsx`**

    A `'use client'` component that displays payment info and allows recording new payments.

    Props:
    ```typescript
    interface PaymentRecorderProps {
      orderId: string
      carrierPay: number
      amountPaid: number
      paymentStatus: PaymentStatus
    }
    ```

    Layout (in a single card):

    1. **Payment Status Header:**
       - Payment status badge (using PAYMENT_STATUS_COLORS from types)
       - Balance summary: "Paid: $X / $Y" with remaining amount
       - Progress bar showing % paid (green fill)

    2. **Payment History:**
       - Use `usePaymentsByOrder(orderId)` hook to fetch payments
       - List each payment: date, amount, notes (if any)
       - If no payments: "No payments recorded"
       - Show loading state while fetching

    3. **Record Payment Form** (only show if paymentStatus !== 'paid'):
       - Amount input (number, step="0.01", max={remaining balance})
       - Date input (type="date", default to today)
       - Notes input (optional text field)
       - "Record Payment" button
       - Use `react-hook-form` with `zodResolver` and `recordPaymentSchema`
       - On submit: call `recordPayment(orderId, data)` server action
       - Show toast on success/error via `sonner`
       - Invalidate `['orders', orderId]` and `['payments', orderId]` queries on success
       - Disable form while submitting (isPending state)

    Use shadcn/ui components: Button, Input, Label. Use `useQueryClient` for cache invalidation.

    **Step 2: Create `src/app/(dashboard)/orders/_components/invoice-button.tsx`**

    A `'use client'` component with two actions: send invoice and download PDF.

    Props:
    ```typescript
    interface InvoiceButtonProps {
      orderId: string
      orderNumber: string | null
      paymentStatus: PaymentStatus
      invoiceDate: string | null
      hasBrokerEmail: boolean
    }
    ```

    Layout:
    1. **Primary action: "Send Invoice" button**
       - Calls `POST /api/invoices/${orderId}/send` via fetch
       - Show loading spinner while sending
       - Disabled if `!hasBrokerEmail` (show tooltip: "Broker email required")
       - After sending, show success toast with "Invoice sent to broker"
       - Invalidate orders query to reflect updated payment_status
       - If already invoiced, button text: "Resend Invoice"

    2. **Secondary action: "Download PDF" link**
       - Opens `/api/invoices/${orderId}/pdf` in new tab
       - Always available (doesn't require broker email)

    3. **Invoice info line:**
       - If invoice_date exists: "Invoiced on {formatted date}"
       - Invoice number: `INV-{orderId}` (uses order UUID per locked decision)

    Use shadcn/ui Button with variant="outline" for download. Use lucide icons: Send, Download, FileText.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `grep 'PaymentRecorder' src/app/(dashboard)/orders/_components/payment-recorder.tsx` returns match
    - `grep 'InvoiceButton' src/app/(dashboard)/orders/_components/invoice-button.tsx` returns match
    - PaymentRecorder uses recordPayment server action
    - InvoiceButton calls /api/invoices endpoint
  </verify>
  <done>PaymentRecorder displays payment status, balance, payment history, and a form to record new payments with validation. InvoiceButton sends invoices via email and provides PDF download.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate billing components into order detail page</name>
  <files>
    src/app/(dashboard)/orders/_components/order-detail.tsx
  </files>
  <action>
    Modify the existing `src/app/(dashboard)/orders/_components/order-detail.tsx` to add a billing section.

    **Changes:**

    1. **Import new components:**
       ```typescript
       import { PaymentRecorder } from './payment-recorder'
       import { InvoiceButton } from './invoice-button'
       import { PAYMENT_STATUS_LABELS, PAYMENT_STATUS_COLORS } from '@/types'
       import type { PaymentStatus } from '@/types'
       ```

    2. **Add billing section** between the Financial Summary card and the Route section. This section should be visible for all order statuses EXCEPT 'new', 'assigned', 'cancelled' (billing is only relevant for picked_up, delivered, invoiced, paid statuses — i.e., orders in the fulfillment/billing stage).

       Condition: `(['picked_up', 'delivered', 'invoiced', 'paid'] as OrderStatus[]).includes(status)`

    3. **Billing section layout** (full-width, lg:col-span-2):
       ```tsx
       <div className="rounded-lg border bg-white p-6 lg:col-span-2">
         <div className="mb-4 flex items-center justify-between">
           <div className="flex items-center gap-2">
             <Receipt className="h-5 w-5 text-gray-400" />
             <h2 className="text-lg font-semibold text-gray-900">Billing</h2>
           </div>
           <InvoiceButton
             orderId={order.id}
             orderNumber={order.order_number}
             paymentStatus={order.payment_status as PaymentStatus}
             invoiceDate={order.invoice_date}
             hasBrokerEmail={!!order.broker?.email}
           />
         </div>
         <PaymentRecorder
           orderId={order.id}
           carrierPay={carrierPay}
           amountPaid={parseFloat(order.amount_paid ?? '0')}
           paymentStatus={order.payment_status as PaymentStatus}
         />
       </div>
       ```

    4. **Add Receipt import** from lucide-react (add to existing imports).

    5. **Update the order detail to handle new fields:**
       The `order` object from `OrderWithRelations` now includes `payment_status`, `invoice_date`, and `amount_paid`. These fields come from the updated database types (Plan 01). The `OrderWithRelations` interface in `src/lib/queries/orders.ts` extends `Order` which now has these fields.

       **No changes needed to OrderWithRelations** — it extends Order, and Order interface was updated in Plan 01.

    6. **Also need broker email in the query.** Check if `OrderWithRelations` includes broker email. Currently the broker select is `brokers(id, name)`. It needs `brokers(id, name, email)` to pass `hasBrokerEmail` to InvoiceButton. Update the select in `fetchOrder` and `fetchOrders` in `src/lib/queries/orders.ts`.

       **WAIT** — `src/lib/queries/orders.ts` is NOT in this plan's files_modified. To avoid file ownership conflict, update the broker select inline in the detail component query if needed, OR note that the OrderWithRelations needs to be updated.

       **Better approach:** Add `email` to the broker Pick in `OrderWithRelations` and update the select strings in `fetchOrder`/`fetchOrders`. Since orders.ts query file is a small change and no other plan touches it, include it in this task.

       In `src/lib/queries/orders.ts`:
       - Update `OrderWithRelations` broker type: `Pick<Broker, 'id' | 'name' | 'email'>`
       - Update both select strings to include `email`: `broker:brokers(id, name, email)`

    **File also modified (add to awareness): `src/lib/queries/orders.ts`** — small addition of `email` to broker select.
  </action>
  <verify>
    - `npx tsc --noEmit` compiles without errors
    - `grep 'PaymentRecorder' src/app/(dashboard)/orders/_components/order-detail.tsx` returns match
    - `grep 'InvoiceButton' src/app/(dashboard)/orders/_components/order-detail.tsx` returns match
    - `grep 'Receipt' src/app/(dashboard)/orders/_components/order-detail.tsx` returns match
    - `grep 'email' src/lib/queries/orders.ts` shows broker email in select
    - Billing section conditionally rendered for appropriate statuses
  </verify>
  <done>Order detail page shows a Billing section for orders past the assignment stage. Section includes InvoiceButton (send/resend invoice, download PDF) and PaymentRecorder (payment status, balance, history, recording form). Broker email is now included in order queries for invoice delivery.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Order detail shows billing section for delivered/invoiced/paid orders
- Payment recording form validates input and updates order status
- Invoice button sends email and shows proper state (send vs resend)
- PDF download opens in new tab
- Payment history updates in real-time via Realtime subscription
</verification>

<success_criteria>
- Billing section appears on order detail for picked_up/delivered/invoiced/paid orders
- PaymentRecorder shows balance, history, and recording form
- InvoiceButton sends invoice via Resend and shows success/error feedback
- Payment status auto-transitions visible after recording
- Broker email included in order query for invoice delivery check
</success_criteria>

<output>
After completion, create `.planning/phases/04-billing-invoicing/04-04-SUMMARY.md`
</output>
