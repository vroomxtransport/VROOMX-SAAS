---
phase: 03-dispatch-workflow
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/app/actions/trips.ts
  - src/app/actions/trip-expenses.ts
  - src/lib/queries/trips.ts
  - src/lib/queries/trip-expenses.ts
  - src/hooks/use-trips.ts
  - src/hooks/use-trip-expenses.ts
  - src/hooks/use-unassigned-orders.ts
autonomous: true

must_haves:
  truths:
    - "Trip CRUD server actions exist (create, update, delete)"
    - "Trip status can be advanced and rolled back with order auto-sync"
    - "Orders can be assigned and unassigned from trips with financial recalculation and route summary update"
    - "Trip expense CRUD server actions exist"
    - "Trips can be queried with driver/truck joins and filters"
    - "Unassigned orders can be queried for assignment UI"
    - "TanStack Query hooks provide reactive data for trips, expenses, and unassigned orders"
  artifacts:
    - path: "src/app/actions/trips.ts"
      provides: "Trip CRUD + status workflow + order assignment + financial recalculation"
      exports: ["createTrip", "updateTrip", "deleteTrip", "updateTripStatus", "assignOrderToTrip", "unassignOrderFromTrip", "recalculateTripFinancials"]
      min_lines: 100
    - path: "src/app/actions/trip-expenses.ts"
      provides: "Trip expense CRUD with auto financial recalculation"
      exports: ["createTripExpense", "updateTripExpense", "deleteTripExpense"]
      min_lines: 40
    - path: "src/lib/queries/trips.ts"
      provides: "Trip fetch functions with driver/truck relations"
      exports: ["fetchTrips", "fetchTrip"]
      min_lines: 40
    - path: "src/lib/queries/trip-expenses.ts"
      provides: "Trip expense fetch function"
      exports: ["fetchTripExpenses"]
      min_lines: 15
    - path: "src/hooks/use-trips.ts"
      provides: "useTrips and useTrip TanStack Query hooks with Realtime"
      exports: ["useTrips", "useTrip"]
      min_lines: 40
    - path: "src/hooks/use-trip-expenses.ts"
      provides: "useTripExpenses hook"
      exports: ["useTripExpenses"]
      min_lines: 20
    - path: "src/hooks/use-unassigned-orders.ts"
      provides: "useUnassignedOrders hook for assignment UI"
      exports: ["useUnassignedOrders"]
      min_lines: 15
  key_links:
    - from: "src/app/actions/trips.ts"
      to: "src/lib/financial/trip-calculations.ts"
      via: "recalculateTripFinancials calls calculateTripFinancials"
      pattern: "import.*calculateTripFinancials"
    - from: "src/app/actions/trips.ts"
      to: "src/lib/supabase/server.ts"
      via: "Server Actions use server Supabase client"
      pattern: "createClient"
    - from: "src/hooks/use-trips.ts"
      to: "src/lib/queries/trips.ts"
      via: "Hook calls fetchTrips query function"
      pattern: "import.*fetchTrips"
---

<objective>
Build all server actions, query functions, and TanStack Query hooks for trips and trip expenses. This is the data layer that powers all Phase 3 UI.

Purpose: Establishes the complete data access layer: trip CRUD, order assignment with auto-status-sync, financial recalculation on mutations, expense management, and reactive client-side hooks with Realtime subscriptions.

Output: 7 files covering server actions, query builders, and TanStack Query hooks for trips, trip expenses, and unassigned orders.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-dispatch-workflow/03-CONTEXT.md
@.planning/phases/03-dispatch-workflow/03-RESEARCH.md
@.planning/phases/03-dispatch-workflow/03-01-SUMMARY.md

# Established patterns to follow exactly:
@src/app/actions/orders.ts
@src/lib/queries/orders.ts
@src/hooks/use-orders.ts
@src/lib/supabase/server.ts
@src/lib/supabase/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Trip server actions with financial recalculation and order assignment</name>
  <files>
    src/app/actions/trips.ts
    src/app/actions/trip-expenses.ts
  </files>
  <action>
**A. Create `src/app/actions/trips.ts`** following the exact pattern from `src/app/actions/orders.ts`:

All server actions must:
- Start with `'use server'`
- Import `createClient` from `@/lib/supabase/server`
- Extract `tenant_id` from `user.app_metadata.tenant_id` (same as orders.ts)
- Validate input with Zod `safeParse` (same pattern as orders.ts)
- Call `revalidatePath()` for affected paths after mutations
- Return `{ success: true }` or `{ error: string }`

**Functions to implement:**

1. **`createTrip(formData: TripFormData)`**
   - Validate with tripSchema.safeParse
   - Insert into trips table with tenant_id
   - Return `{ success: true, tripId: data.id }`
   - Revalidate: `/dispatch`

2. **`updateTrip(id: string, formData: Partial<TripFormData>)`**
   - Validate partial input
   - Update trips table where id matches
   - If carrier_pay changed, call `recalculateTripFinancials(id)`
   - Revalidate: `/dispatch`, `/trips/${id}`

3. **`deleteTrip(id: string)`**
   - First, unassign all orders from this trip: `UPDATE orders SET trip_id = NULL, status = 'new' WHERE trip_id = id`
   - Delete from trips table
   - Revalidate: `/dispatch`, `/orders`

4. **`updateTripStatus(id: string, newStatus: TripStatus)`**
   - Update trip status
   - **Auto-sync order statuses (from CONTEXT.md decisions):**
     - Trip → `in_progress`: Update all trip's orders to `picked_up`
     - Trip → `completed`: Update all trip's orders to `delivered`
     - Trip → `planned` (rollback): Update all trip's orders to `assigned`
     - Trip → `at_terminal`: No order status change
   - Revalidate: `/dispatch`, `/trips/${id}`, `/orders`

5. **`assignOrderToTrip(orderId: string, tripId: string)`**
   - Get order's current trip_id (old trip)
   - Update order: set `trip_id = tripId`, `status = 'assigned'`
   - Recalculate old trip financials if it had one
   - Recalculate new trip financials
   - Revalidate: `/dispatch`, `/trips/${tripId}`, `/trips/${oldTripId}` (if exists), `/orders/${orderId}`, `/orders`

6. **`unassignOrderFromTrip(orderId: string)`**
   - Get order's current trip_id
   - Update order: set `trip_id = null`, `status = 'new'`
   - Recalculate old trip financials
   - Revalidate: `/dispatch`, `/trips/${oldTripId}`, `/orders/${orderId}`, `/orders`

7. **`recalculateTripFinancials(tripId: string)`** (internal helper, also exported for use in trip-expenses.ts)
   - Fetch trip with driver relation: `trips.select('*, driver:drivers(driver_type, pay_type, pay_rate)').eq('id', tripId).single()`
   - Fetch trip's orders: `orders.select('revenue, broker_fee, pickup_state, delivery_state, created_at').eq('trip_id', tripId).order('created_at', { ascending: true })`
   - Fetch trip's expenses: `trip_expenses.select('amount').eq('trip_id', tripId)`
   - Import and call `calculateTripFinancials()` from `@/lib/financial/trip-calculations.ts`
   - Parse numeric strings to numbers: `parseFloat(order.revenue || '0')` etc.
   - **Compute route summary from orders:**
     - Collect unique `pickup_state` values from all orders. Use the first order's pickup_state as the primary origin. If multiple unique pickup states exist, join them: e.g., "FL, GA". Store as `origin_summary`.
     - Collect unique `delivery_state` values from all orders. Use the last order's delivery_state as the primary destination. If multiple unique delivery states exist, join them: e.g., "NY, PA". Store as `destination_summary`.
     - If no orders, set both to `null`.
     - Format: Use the 2-letter state abbreviation directly from the order fields (already stored as abbreviations like "FL", "NY").
   - Update trip with denormalized values: total_revenue, total_broker_fees, driver_pay, total_expenses, net_profit, order_count, origin_summary, destination_summary
   - Note: carrier_pay is NOT recalculated (it's manually entered)

**B. Create `src/app/actions/trip-expenses.ts`:**

1. **`createTripExpense(tripId: string, formData: TripExpenseFormData)`**
   - Validate with tripExpenseSchema.safeParse
   - Insert into trip_expenses with tenant_id and trip_id
   - Call `recalculateTripFinancials(tripId)` from trips.ts
   - Revalidate: `/trips/${tripId}`, `/dispatch`

2. **`updateTripExpense(id: string, tripId: string, formData: Partial<TripExpenseFormData>)`**
   - Update trip_expenses where id matches
   - Call `recalculateTripFinancials(tripId)`
   - Revalidate: `/trips/${tripId}`, `/dispatch`

3. **`deleteTripExpense(id: string, tripId: string)`**
   - Delete from trip_expenses
   - Call `recalculateTripFinancials(tripId)`
   - Revalidate: `/trips/${tripId}`, `/dispatch`

**IMPORTANT:** The `recalculateTripFinancials` function is called from BOTH trips.ts and trip-expenses.ts. Export it from trips.ts and import it in trip-expenses.ts.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Review each server action for:
- 'use server' directive present
- tenant_id extraction from app_metadata
- Zod validation where applicable
- recalculateTripFinancials called after every mutation that affects financials
- recalculateTripFinancials also computes and saves origin_summary and destination_summary from orders
- revalidatePath called for all affected routes
- Both old AND new trip recalculated on order reassignment
  </verify>
  <done>Trip CRUD, status workflow with order auto-sync, order assignment/unassignment with dual-trip recalculation (including route summary), and expense CRUD with recalculation all implemented as Server Actions</done>
</task>

<task type="auto">
  <name>Task 2: Trip queries and TanStack Query hooks with Realtime</name>
  <files>
    src/lib/queries/trips.ts
    src/lib/queries/trip-expenses.ts
    src/hooks/use-trips.ts
    src/hooks/use-trip-expenses.ts
    src/hooks/use-unassigned-orders.ts
  </files>
  <action>
**A. Create `src/lib/queries/trips.ts`** following `src/lib/queries/orders.ts` pattern:

```typescript
// Define TripFilters interface:
interface TripFilters {
  status?: TripStatus
  driverId?: string
  truckId?: string
  startDate?: string  // filter trips starting on or after this date
  endDate?: string    // filter trips ending on or before this date
  search?: string     // search by trip_number
  page?: number
  pageSize?: number
}

// TripWithRelations: Trip + embedded driver and truck
interface TripWithRelations extends Trip {
  driver: Pick<Driver, 'id' | 'first_name' | 'last_name' | 'driver_type' | 'pay_type' | 'pay_rate'> | null
  truck: Pick<Truck, 'id' | 'unit_number' | 'truck_type'> | null
}
```

1. **`fetchTrips(supabase, filters)`**
   - Select with driver and truck relations: `'*, driver:drivers(id, first_name, last_name, driver_type, pay_type, pay_rate), truck:trucks(id, unit_number, truck_type)'`
   - Apply filters: status `.eq()`, driverId `.eq()`, truckId `.eq()`, date range `.gte()/.lte()`, search `.ilike('trip_number', ...)`
   - Use `{ count: 'exact' }` for total count
   - Paginate with `.range()`
   - Order by `start_date` descending
   - Return `{ trips, total }`

2. **`fetchTrip(supabase, id)`**
   - Select single trip with driver and truck relations (same select string)
   - Return single trip or null

**B. Create `src/lib/queries/trip-expenses.ts`:**

1. **`fetchTripExpenses(supabase, tripId)`**
   - Select all expenses for a trip ordered by `expense_date` descending, then `created_at` descending
   - Return `{ expenses }`

**C. Create `src/hooks/use-trips.ts`** following `src/hooks/use-orders.ts` pattern:

1. **`useTrips(filters)`**
   - TanStack Query with queryKey `['trips', filters]`
   - Call `fetchTrips(supabase, filters)`
   - Realtime: Subscribe to `postgres_changes` on `trips` table AND `orders` table (order assignment changes affect trip display)
   - On change, `queryClient.invalidateQueries({ queryKey: ['trips'] })`
   - Return query result

2. **`useTrip(id)`**
   - TanStack Query with queryKey `['trip', id]`
   - Call `fetchTrip(supabase, id)`
   - Realtime: Subscribe to `postgres_changes` on `trips` table filtered by `filter: 'id=eq.${id}'` (same pattern as useOrder)
   - Also subscribe to `orders` table filtered by `filter: 'trip_id=eq.${id}'` for order changes
   - Also subscribe to `trip_expenses` table filtered by `filter: 'trip_id=eq.${id}'`
   - Return query result

**D. Create `src/hooks/use-trip-expenses.ts`:**

1. **`useTripExpenses(tripId)`**
   - TanStack Query with queryKey `['trip-expenses', tripId]`
   - Call `fetchTripExpenses(supabase, tripId)`
   - Realtime: Subscribe to `trip_expenses` table filtered by `filter: 'trip_id=eq.${tripId}'`
   - Return query result

**E. Create `src/hooks/use-unassigned-orders.ts`:**

1. **`useUnassignedOrders(search?)`**
   - TanStack Query with queryKey `['unassigned-orders', search]`
   - Query: `supabase.from('orders').select('*, broker:brokers(id, name)').is('trip_id', null).in('status', ['new', 'assigned'])` -- orders not assigned to any trip
   - If search provided, add `.or('order_number.ilike.%${search}%, vehicle_vin.ilike.%${search}%, vehicle_make.ilike.%${search}%')`
   - Order by `created_at` descending
   - Realtime: Subscribe to `orders` table changes to keep the list fresh
   - Return query result

All hooks must follow the established pattern: create Supabase browser client with `createClient()` from `@/lib/supabase/client`, use `useQueryClient()` for invalidation, subscribe to Realtime in `useEffect` with cleanup via `supabase.removeChannel()`.
  </action>
  <verify>
Run `npx tsc --noEmit` to verify TypeScript compilation. Check each file for:
- Correct import paths (@/lib/supabase/client for hooks, SupabaseClient type for queries)
- Query keys are unique and include filter parameters
- Realtime subscriptions in useEffect with cleanup
- fetchTrips includes driver + truck relation joins
- useUnassignedOrders filters for trip_id IS NULL
  </verify>
  <done>Query functions fetch trips with driver/truck relations and filters. TanStack Query hooks provide reactive data with Realtime subscriptions for trips, trip expenses, and unassigned orders.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors across all 7 new files
2. Server actions use 'use server' directive and extract tenant_id correctly
3. recalculateTripFinancials is called after every financial mutation and updates origin_summary/destination_summary
4. assignOrderToTrip recalculates BOTH old and new trips (including route summaries)
5. updateTripStatus auto-syncs order statuses correctly
6. Hooks subscribe to appropriate Realtime channels with cleanup
7. fetchTrips returns trips with driver and truck joined data
8. useUnassignedOrders filters for orders with null trip_id
</verification>

<success_criteria>
- All 7 exported server action functions work with Supabase RLS
- Order assignment syncs status and recalculates both trips (financials + route summary)
- Trip status changes cascade to order statuses
- Expense mutations trigger trip financial recalculation
- Query functions support all filter parameters
- Hooks invalidate on Realtime changes
- TypeScript compilation passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-dispatch-workflow/03-03-SUMMARY.md`
</output>
