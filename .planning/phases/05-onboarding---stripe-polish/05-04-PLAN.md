---
phase: 05-onboarding---stripe-polish
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/actions/invites.ts
  - src/components/email/invite-email.tsx
  - src/app/(auth)/invite/accept/route.ts
  - src/app/(auth)/login/page.tsx
  - src/app/(auth)/signup/page.tsx
  - src/app/actions/auth.ts
  - src/app/(dashboard)/settings/page.tsx
  - src/app/(dashboard)/settings/team-section.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can send an invite email to a new team member"
    - "Invite email contains accept link with token"
    - "Clicking accept link adds user to tenant with correct role"
    - "Accepted user's app_metadata is updated with tenant_id and role"
    - "Pending invites are listed on the settings page"
    - "Duplicate invite to same email in same tenant is prevented"
    - "Expired invites cannot be accepted"
    - "Unauthenticated user clicking invite link can login or signup and is auto-redirected to accept the invite"
  artifacts:
    - path: "src/app/actions/invites.ts"
      provides: "sendInvite and revokeInvite Server Actions"
      exports: ["sendInvite", "revokeInvite"]
    - path: "src/components/email/invite-email.tsx"
      provides: "React Email template for team invitations"
      contains: "InviteEmail"
    - path: "src/app/(auth)/invite/accept/route.ts"
      provides: "GET route handler for invite acceptance"
      exports: ["GET"]
    - path: "src/app/(auth)/login/page.tsx"
      provides: "Login page that preserves invite_token through auth flow"
      contains: "invite_token"
    - path: "src/app/actions/auth.ts"
      provides: "loginAction and signUpAction that redirect to invite accept route when invite_token is present"
      contains: "invite_token"
    - path: "src/app/(dashboard)/settings/page.tsx"
      provides: "Settings page with team management section"
      contains: "TeamSection"
    - path: "src/app/(dashboard)/settings/team-section.tsx"
      provides: "Team members list and invite form component"
      contains: "TeamSection"
  key_links:
    - from: "src/app/actions/invites.ts"
      to: "src/components/email/invite-email.tsx"
      via: "Resend sends invite email using React Email template"
      pattern: "InviteEmail"
    - from: "src/app/(auth)/invite/accept/route.ts"
      to: "src/app/actions/invites.ts"
      via: "Accept route validates token and adds user to tenant"
      pattern: "tenant_memberships.*insert"
    - from: "src/app/(dashboard)/settings/team-section.tsx"
      to: "src/app/actions/invites.ts"
      via: "Invite form calls sendInvite action"
      pattern: "sendInvite"
    - from: "src/app/actions/auth.ts"
      to: "src/app/(auth)/invite/accept/route.ts"
      via: "Auth actions redirect to /invite/accept?token= when invite_token is present in form data"
      pattern: "invite_token.*invite/accept"
---

<objective>
Build the complete team invite flow: send invite email, accept invite, manage pending invites on settings page.

Purpose: Requirement AUTH-6 -- team members can be invited and join a tenant with the correct role. This enables multi-user organizations.
Output: Invite Server Actions, email template, accept route, settings page with team management.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/app/actions/auth.ts
@src/app/(auth)/login/page.tsx
@src/app/(auth)/signup/page.tsx
@src/components/email/invoice-email.tsx
@src/lib/resend/client.ts
@src/lib/supabase/server.ts
@src/lib/supabase/service-role.ts
@src/lib/validations/invite.ts
@src/types/index.ts
@.planning/phases/05-onboarding---stripe-polish/05-01-SUMMARY.md
@.planning/phases/05-onboarding---stripe-polish/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invite Server Actions, email template, accept route, and wire invite_token through login/signup</name>
  <files>src/app/actions/invites.ts, src/components/email/invite-email.tsx, src/app/(auth)/invite/accept/route.ts, src/app/(auth)/login/page.tsx, src/app/(auth)/signup/page.tsx, src/app/actions/auth.ts</files>
  <action>
**1. Create `src/components/email/invite-email.tsx`:**

Follow the exact same pattern as `invoice-email.tsx` (React Email components, inline styles):

```typescript
import {
  Body, Container, Head, Heading, Hr, Html, Link, Preview, Section, Text,
} from '@react-email/components'

interface InviteEmailProps {
  tenantName: string
  inviterName: string
  role: string
  acceptUrl: string
}

export function InviteEmail({ tenantName, inviterName, role, acceptUrl }: InviteEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>You've been invited to join {tenantName} on VroomX</Preview>
      <Body style={bodyStyle}>
        <Container style={containerStyle}>
          <Heading style={headingStyle}>Team Invitation</Heading>

          <Text style={textStyle}>
            {inviterName} has invited you to join <strong>{tenantName}</strong> on VroomX
            as a <strong>{role}</strong>.
          </Text>

          <Section style={buttonSectionStyle}>
            <Link href={acceptUrl} style={buttonStyle}>
              Accept Invitation
            </Link>
          </Section>

          <Hr style={hrStyle} />

          <Text style={footerStyle}>
            This invitation expires in 72 hours. If you didn't expect this email, you can safely ignore it.
          </Text>
        </Container>
      </Body>
    </Html>
  )
}
```

Add inline styles matching invoice-email.tsx pattern. Add button styles:
```typescript
const buttonSectionStyle: React.CSSProperties = {
  textAlign: 'center' as const,
  marginTop: '24px',
  marginBottom: '24px',
}

const buttonStyle: React.CSSProperties = {
  display: 'inline-block',
  backgroundColor: '#2563eb',
  color: '#ffffff',
  padding: '12px 24px',
  borderRadius: '6px',
  fontSize: '14px',
  fontWeight: 'bold',
  textDecoration: 'none',
}
```

Reuse bodyStyle, containerStyle, headingStyle, textStyle, hrStyle, footerStyle with same values as invoice-email.tsx.

**2. Create `src/app/actions/invites.ts`:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { resend } from '@/lib/resend/client'
import { inviteSchema } from '@/lib/validations/invite'
import { checkTierLimit } from '@/lib/tier'
import { hasMinRole } from '@/lib/tier'
import { InviteEmail } from '@/components/email/invite-email'
import { render } from '@react-email/render'
import { revalidatePath } from 'next/cache'

export async function sendInvite(data: unknown) {
  const parsed = inviteSchema.safeParse(data)
  if (!parsed.success) {
    return { error: parsed.error.flatten().fieldErrors }
  }

  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const tenantId = user.app_metadata?.tenant_id
  const userRole = user.app_metadata?.role
  if (!tenantId) return { error: 'No tenant found' }

  // Only admins and owners can invite
  if (!hasMinRole(userRole, 'admin')) {
    return { error: 'You do not have permission to invite team members' }
  }

  // Check user limit before inviting (count accepted members only)
  const tierCheck = await checkTierLimit(supabase, tenantId, 'users')
  if (!tierCheck.allowed) {
    if (tierCheck.limit === 0) {
      return { error: 'Your account is suspended. Please update your payment method.' }
    }
    return { error: `Team member limit reached (${tierCheck.current}/${tierCheck.limit}). Upgrade your plan to add more team members.` }
  }

  // Check for existing pending invite to same email in this tenant
  const admin = createServiceRoleClient()
  const { data: existingInvite } = await admin
    .from('invites')
    .select('id')
    .eq('tenant_id', tenantId)
    .eq('email', parsed.data.email)
    .eq('status', 'pending')
    .single()

  if (existingInvite) {
    return { error: 'An invite has already been sent to this email address' }
  }

  // Check if user is already a member of this tenant
  const { data: existingMember } = await admin
    .from('tenant_memberships')
    .select('id, user_id!inner(email)')
    .eq('tenant_id', tenantId)

  // Note: We can't easily join auth.users from supabase-js, so check differently:
  // Look up user by email to see if they're already a member
  const { data: existingUserData } = await admin.auth.admin.listUsers()
  const existingUser = existingUserData?.users?.find(u => u.email === parsed.data.email)
  if (existingUser) {
    const { data: membership } = await admin
      .from('tenant_memberships')
      .select('id')
      .eq('tenant_id', tenantId)
      .eq('user_id', existingUser.id)
      .single()

    if (membership) {
      return { error: 'This user is already a member of your organization' }
    }
  }

  // Create invite token (crypto.randomUUID)
  const token = crypto.randomUUID()
  const expiresAt = new Date(Date.now() + 72 * 60 * 60 * 1000) // 72 hours

  const { error: insertError } = await admin
    .from('invites')
    .insert({
      tenant_id: tenantId,
      email: parsed.data.email,
      role: parsed.data.role,
      token,
      invited_by: user.id,
      expires_at: expiresAt.toISOString(),
      status: 'pending',
    })

  if (insertError) {
    console.error('Failed to create invite:', insertError)
    return { error: 'Failed to create invite' }
  }

  // Fetch tenant name for email
  const { data: tenant } = await supabase
    .from('tenants')
    .select('name')
    .eq('id', tenantId)
    .single()

  // Send invite email via Resend with React Email template
  const acceptUrl = `${process.env.NEXT_PUBLIC_APP_URL}/invite/accept?token=${token}`
  const inviterName = user.user_metadata?.full_name || user.email || 'A team member'

  const emailHtml = await render(InviteEmail({
    tenantName: tenant?.name || 'Your team',
    inviterName,
    role: parsed.data.role,
    acceptUrl,
  }))

  try {
    await resend.emails.send({
      from: `${tenant?.name || 'VroomX'} <${process.env.RESEND_FROM_EMAIL || 'onboarding@resend.dev'}>`,
      to: [parsed.data.email],
      subject: `You've been invited to join ${tenant?.name || 'a team'} on VroomX`,
      html: emailHtml,
    })
  } catch (emailError) {
    console.error('Failed to send invite email:', emailError)
    // Don't fail the invite -- it's created in DB. User can resend.
  }

  revalidatePath('/settings')
  return { success: true }
}

export async function revokeInvite(inviteId: string) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const userRole = user.app_metadata?.role
  if (!hasMinRole(userRole, 'admin')) {
    return { error: 'You do not have permission to revoke invites' }
  }

  const tenantId = user.app_metadata?.tenant_id
  const admin = createServiceRoleClient()

  const { error } = await admin
    .from('invites')
    .update({ status: 'revoked' })
    .eq('id', inviteId)
    .eq('tenant_id', tenantId) // Security: only revoke own tenant's invites

  if (error) {
    return { error: 'Failed to revoke invite' }
  }

  revalidatePath('/settings')
  return { success: true }
}
```

**Important notes on the existing member check:** The `listUsers` approach is heavy. For a simpler alternative, skip the full member check and let the accept route handle it (it will fail on unique constraint if user is already a member). Keep the simple duplicate pending invite check only. Remove the `listUsers` block and replace it with a comment: `// Duplicate membership is caught by unique constraint on acceptance`.

Actually, revise the approach: Remove the heavy `listUsers` call. Instead, just check for duplicate pending invites (already done) and let the accept flow handle the case where the user is already a member. This is simpler and more efficient.

**3. Create `src/app/(auth)/invite/accept/route.ts`:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { redirect } from 'next/navigation'

export async function GET(request: NextRequest) {
  const token = request.nextUrl.searchParams.get('token')

  if (!token) {
    return redirect('/login?error=' + encodeURIComponent('Invalid invite link'))
  }

  const admin = createServiceRoleClient()

  // 1. Validate invite token
  const { data: invite, error: inviteError } = await admin
    .from('invites')
    .select('*')
    .eq('token', token)
    .eq('status', 'pending')
    .single()

  if (inviteError || !invite) {
    return redirect('/login?error=' + encodeURIComponent('Invalid or expired invite'))
  }

  // Check expiry
  if (new Date(invite.expires_at) < new Date()) {
    // Mark as expired
    await admin.from('invites').update({ status: 'expired' }).eq('id', invite.id)
    return redirect('/login?error=' + encodeURIComponent('This invite has expired'))
  }

  // 2. Check if user is authenticated
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (user) {
    // User is logged in -- add to tenant directly
    try {
      // Check if already a member
      const { data: existingMembership } = await admin
        .from('tenant_memberships')
        .select('id')
        .eq('tenant_id', invite.tenant_id)
        .eq('user_id', user.id)
        .single()

      if (existingMembership) {
        // Already a member -- mark invite as accepted and redirect
        await admin.from('invites').update({ status: 'accepted', accepted_at: new Date().toISOString() }).eq('id', invite.id)
        return redirect('/dashboard')
      }

      // Add to tenant_memberships
      const { error: memberError } = await admin
        .from('tenant_memberships')
        .insert({
          tenant_id: invite.tenant_id,
          user_id: user.id,
          role: invite.role,
        })

      if (memberError) {
        console.error('Failed to add member:', memberError)
        return redirect('/dashboard?error=' + encodeURIComponent('Failed to join team'))
      }

      // Update user's app_metadata with new tenant_id and role
      // CRITICAL: This is necessary for JWT hook to include tenant info (see Pitfall 6)
      await admin.auth.admin.updateUserById(user.id, {
        app_metadata: {
          tenant_id: invite.tenant_id,
          role: invite.role,
          plan: 'trial', // Will be updated on next JWT refresh via hook
        },
      })

      // Mark invite as accepted
      await admin.from('invites').update({
        status: 'accepted',
        accepted_at: new Date().toISOString(),
      }).eq('id', invite.id)

      return redirect('/dashboard')
    } catch (err) {
      console.error('Invite acceptance error:', err)
      return redirect('/dashboard?error=' + encodeURIComponent('Failed to join team'))
    }
  }

  // 3. Not logged in -- redirect to login/signup with invite context
  // Store token in URL so after login, user can be redirected back
  return redirect(`/login?invite_token=${token}`)
}
```

**4. Wire `invite_token` through login/signup pages and auth actions:**

The accept route redirects unauthenticated users to `/login?invite_token=<token>`. The login and signup pages must preserve this token through the auth flow so that after successful authentication, the user is automatically redirected back to `/invite/accept?token=<token>` to complete the invite acceptance.

**4a. Update `src/app/(auth)/login/page.tsx`:**

The login page is a client component using `useActionState`. Changes needed:

- Read `invite_token` from URL search params using `useSearchParams()` from `next/navigation`
- Add a hidden input `<input type="hidden" name="invite_token" value={inviteToken || ''} />` inside the form
- Pass `invite_token` through to the signup link: change `<Link href="/signup">` to `<Link href={inviteToken ? `/signup?invite_token=${inviteToken}` : '/signup'}>` so new users who need to sign up don't lose the token
- Show an info banner when `invite_token` is present: "Sign in to accept your team invitation" (blue info box above the form)
- Wrap the page in `<Suspense>` since `useSearchParams()` requires it in Next.js App Router

```typescript
'use client'

import { loginAction } from '@/app/actions/auth'
import { Button } from '@/components/ui/button'
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card'
import { Input } from '@/components/ui/input'
import { Label } from '@/components/ui/label'
import Link from 'next/link'
import { useActionState } from 'react'
import { useSearchParams } from 'next/navigation'
import { Suspense } from 'react'

function LoginForm() {
  const searchParams = useSearchParams()
  const inviteToken = searchParams.get('invite_token')
  const [state, formAction, isPending] = useActionState(loginAction, null)

  return (
    <Card>
      <CardHeader>
        <CardTitle className="text-2xl font-bold">VroomX</CardTitle>
        <CardDescription>Sign in to your account</CardDescription>
      </CardHeader>
      <CardContent>
        {inviteToken && (
          <div className="mb-4 rounded-md bg-blue-50 p-3 text-sm text-blue-700">
            Sign in to accept your team invitation.
          </div>
        )}
        {state?.error && (
          <div className="mb-4 rounded-md bg-destructive/10 p-3 text-sm text-destructive">
            {state.error}
          </div>
        )}
        <form action={formAction} className="space-y-4">
          {inviteToken && <input type="hidden" name="invite_token" value={inviteToken} />}
          {/* ...existing email/password fields unchanged... */}
          <Button type="submit" className="w-full" disabled={isPending}>
            {isPending ? 'Signing in...' : 'Sign in'}
          </Button>
        </form>
      </CardContent>
      <CardFooter className="flex justify-center">
        <p className="text-sm text-muted-foreground">
          Don't have an account?{' '}
          <Link
            href={inviteToken ? `/signup?invite_token=${inviteToken}` : '/signup'}
            className="font-medium text-primary hover:underline"
          >
            Sign up
          </Link>
        </p>
      </CardFooter>
    </Card>
  )
}

export default function LoginPage() {
  return (
    <Suspense>
      <LoginForm />
    </Suspense>
  )
}
```

**4b. Update `src/app/(auth)/signup/page.tsx`:**

Same pattern -- read `invite_token` from search params, add hidden input, pass to login link:

- `useSearchParams()` to read `invite_token`
- Hidden input: `<input type="hidden" name="invite_token" value={inviteToken || ''} />`
- Update login link: `<Link href={inviteToken ? `/login?invite_token=${inviteToken}` : '/login'}>`
- Show info banner when invite_token is present: "Create an account to accept your team invitation"
- Wrap in `<Suspense>`
- When invite_token is present, hide the plan selection (invited users join an existing tenant, they don't need their own plan). Instead, add a hidden input `<input type="hidden" name="plan" value="starter" />` as a placeholder (the invite acceptance will set the correct tenant/plan).
- Also hide the company_name field when invite_token is present (they're joining an existing org). Use a hidden input with a placeholder value: `<input type="hidden" name="company_name" value="Invited User" />`

**4c. Update `src/app/actions/auth.ts`:**

Modify both `loginAction` and `signUpAction` to check for `invite_token` in formData and redirect accordingly:

In `loginAction`:
```typescript
export async function loginAction(prevState: any, formData: FormData) {
  const supabase = await createClient()
  const email = formData.get('email') as string
  const password = formData.get('password') as string
  const inviteToken = formData.get('invite_token') as string | null

  const { error } = await supabase.auth.signInWithPassword({ email, password })
  if (error) {
    return { error: error.message }
  }

  revalidatePath('/', 'layout')

  // If invite_token present, redirect to accept route instead of dashboard
  if (inviteToken) {
    redirect(`/invite/accept?token=${inviteToken}`)
  }

  redirect('/dashboard')
}
```

In `signUpAction`, after step 6 (set app_metadata), check for invite_token:
```typescript
  const inviteToken = formData.get('invite_token') as string | null

  // If this signup was triggered from an invite link, skip Stripe Checkout
  // and redirect to the invite accept route. The user will join the inviting
  // tenant, not create their own. The tenant/membership/plan are all handled
  // by the accept route.
  if (inviteToken) {
    // Still sign them in so the accept route sees an authenticated user
    await supabase.auth.signInWithPassword({ email, password })
    revalidatePath('/', 'layout')
    redirect(`/invite/accept?token=${inviteToken}`)
  }

  // 7. Create Stripe Checkout Session with 14-day trial (existing code)
  // ...
```

**Important:** When `invite_token` is present during signup, the signup still creates a Supabase user, a placeholder tenant, and a Stripe customer (steps 2-6). The accept route will then switch the user to the inviting tenant. This is acceptable -- the placeholder tenant has no data and the Stripe subscription checkout is skipped. The placeholder tenant can be cleaned up later or will simply remain unused. A cleaner approach would be to skip tenant/Stripe creation entirely when invite_token is present, but that requires more refactoring. For now, use this approach:

Actually, the CLEANER approach: When `invite_token` is present, skip steps 3-7 (no Stripe customer, no tenant, no membership, no checkout). Just create the auth user (step 2) and set minimal app_metadata, then redirect to accept route:

```typescript
  if (inviteToken) {
    // Invited user: just create auth user, skip tenant/Stripe setup.
    // The accept route will assign them to the inviting tenant.
    await admin.auth.admin.updateUserById(authData.user.id, {
      app_metadata: { pending_invite: true },
    })
    // Sign them in
    await supabase.auth.signInWithPassword({ email, password })
    revalidatePath('/', 'layout')
    redirect(`/invite/accept?token=${inviteToken}`)
  }

  // 3. Create Stripe customer (only for non-invited users)
  // ... rest of existing signup flow
```

This approach is cleaner because invited users don't need their own tenant or Stripe customer.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify invite email template renders correctly. Verify accept route handles: valid token + logged in user, expired token, invalid token. Verify sendInvite checks tier limits and role permissions. Verify login page shows invite banner and passes invite_token to loginAction. Verify signup page hides plan/company fields when invite_token is present. Verify loginAction redirects to /invite/accept when invite_token is present. Verify signUpAction skips tenant/Stripe creation and redirects to /invite/accept when invite_token is present.</verify>
  <done>sendInvite creates invite record, sends React Email template via Resend, checks tier limits and role permissions. revokeInvite marks invite as revoked. Accept route validates token expiry, adds user to tenant_memberships, updates app_metadata, marks invite as accepted. Expired/invalid tokens redirect with error. Login and signup pages preserve invite_token through hidden form fields, show contextual banners, and auth actions redirect to /invite/accept?token= after successful authentication when invite_token is present. Signup with invite_token skips tenant/Stripe creation.</done>
</task>

<task type="auto">
  <name>Task 2: Create settings page with team management section</name>
  <files>src/app/(dashboard)/settings/page.tsx, src/app/(dashboard)/settings/team-section.tsx</files>
  <action>
**1. Create `src/app/(dashboard)/settings/page.tsx`:**

Server Component that fetches tenant data, team members, and pending invites. Follow the existing dashboard page pattern (server component with data fetching):

```typescript
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { redirect } from 'next/navigation'
import { TeamSection } from './team-section'
import type { TenantRole } from '@/types'

export default async function SettingsPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  const tenantId = user.app_metadata?.tenant_id
  const userRole = user.app_metadata?.role as TenantRole

  if (!tenantId) redirect('/login')

  // Fetch tenant details
  const { data: tenant } = await supabase
    .from('tenants')
    .select('id, name, plan, subscription_status, stripe_customer_id')
    .eq('id', tenantId)
    .single()

  if (!tenant) redirect('/login')

  // Fetch team members (memberships + user info via service role)
  const admin = createServiceRoleClient()
  const { data: memberships } = await admin
    .from('tenant_memberships')
    .select('id, user_id, role, created_at')
    .eq('tenant_id', tenantId)
    .order('created_at', { ascending: true })

  // Fetch user details for each membership
  const { data: usersData } = await admin.auth.admin.listUsers({ perPage: 100 })
  const userMap = new Map(
    (usersData?.users || []).map(u => [u.id, { email: u.email || '', name: u.user_metadata?.full_name || '' }])
  )

  const teamMembers = (memberships || []).map(m => ({
    id: m.id,
    userId: m.user_id,
    email: userMap.get(m.user_id)?.email || 'Unknown',
    name: userMap.get(m.user_id)?.name || '',
    role: m.role as TenantRole,
    joinedAt: m.created_at,
  }))

  // Fetch pending invites
  const { data: pendingInvites } = await supabase
    .from('invites')
    .select('id, email, role, created_at, expires_at')
    .eq('tenant_id', tenantId)
    .eq('status', 'pending')
    .order('created_at', { ascending: false })

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-gray-900">Settings</h1>
        <p className="mt-2 text-gray-600">Manage your organization and team.</p>
      </div>

      {(userRole === 'owner' || userRole === 'admin') && (
        <TeamSection
          teamMembers={teamMembers}
          pendingInvites={pendingInvites || []}
          currentUserId={user.id}
          userRole={userRole}
          plan={tenant.plan}
        />
      )}
    </div>
  )
}
```

**2. Create `src/app/(dashboard)/settings/team-section.tsx`:**

Client component for team management (invite form + member list + pending invites):

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { sendInvite, revokeInvite } from '@/app/actions/invites'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { toast } from 'sonner'
import { UserPlus, X, Mail, Clock } from 'lucide-react'
import type { TenantRole } from '@/types'
import { INVITABLE_ROLES } from '@/types'

interface TeamMember {
  id: string
  userId: string
  email: string
  name: string
  role: TenantRole
  joinedAt: string
}

interface PendingInvite {
  id: string
  email: string
  role: string
  created_at: string
  expires_at: string
}

interface TeamSectionProps {
  teamMembers: TeamMember[]
  pendingInvites: PendingInvite[]
  currentUserId: string
  userRole: TenantRole
  plan: string
}

export function TeamSection({
  teamMembers,
  pendingInvites,
  currentUserId,
  userRole,
  plan,
}: TeamSectionProps) {
  const router = useRouter()
  const [email, setEmail] = useState('')
  const [role, setRole] = useState<string>('dispatcher')
  const [sending, setSending] = useState(false)

  async function handleInvite(e: React.FormEvent) {
    e.preventDefault()
    if (!email) return

    setSending(true)
    const result = await sendInvite({ email, role })
    setSending(false)

    if (result?.error) {
      const errorMsg = typeof result.error === 'string' ? result.error : 'Invalid input'
      toast.error(errorMsg)
      return
    }

    toast.success(`Invite sent to ${email}`)
    setEmail('')
    router.refresh()
  }

  async function handleRevoke(inviteId: string) {
    const result = await revokeInvite(inviteId)
    if (result?.error) {
      toast.error(result.error)
      return
    }
    toast.success('Invite revoked')
    router.refresh()
  }

  return (
    <div className="space-y-6">
      {/* Invite form */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <UserPlus className="h-5 w-5" />
            Invite Team Member
          </CardTitle>
          <CardDescription>
            Send an email invitation to add someone to your organization.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleInvite} className="flex gap-3">
            <Input
              type="email"
              placeholder="colleague@example.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="flex-1"
              required
            />
            <Select value={role} onValueChange={setRole}>
              <SelectTrigger className="w-[140px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {INVITABLE_ROLES.map((r) => (
                  <SelectItem key={r} value={r} className="capitalize">
                    {r}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button type="submit" disabled={sending}>
              {sending ? 'Sending...' : 'Send Invite'}
            </Button>
          </form>
        </CardContent>
      </Card>

      {/* Team members */}
      <Card>
        <CardHeader>
          <CardTitle>Team Members ({teamMembers.length})</CardTitle>
          <CardDescription>People who have access to your organization.</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="divide-y">
            {teamMembers.map((member) => (
              <div key={member.id} className="flex items-center justify-between py-3">
                <div className="flex items-center gap-3">
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-gray-100 text-sm font-medium text-gray-600">
                    {(member.name || member.email)[0]?.toUpperCase()}
                  </div>
                  <div>
                    <p className="text-sm font-medium text-gray-900">
                      {member.name || member.email}
                      {member.userId === currentUserId && (
                        <span className="ml-2 text-xs text-gray-500">(you)</span>
                      )}
                    </p>
                    <p className="text-xs text-gray-500">{member.email}</p>
                  </div>
                </div>
                <Badge variant="secondary" className="capitalize">
                  {member.role}
                </Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Pending invites */}
      {pendingInvites.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Mail className="h-5 w-5" />
              Pending Invites ({pendingInvites.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="divide-y">
              {pendingInvites.map((invite) => {
                const isExpired = new Date(invite.expires_at) < new Date()
                return (
                  <div key={invite.id} className="flex items-center justify-between py-3">
                    <div className="flex items-center gap-3">
                      <Clock className="h-4 w-4 text-gray-400" />
                      <div>
                        <p className="text-sm font-medium text-gray-900">{invite.email}</p>
                        <p className="text-xs text-gray-500">
                          {isExpired ? 'Expired' : `Expires ${new Date(invite.expires_at).toLocaleDateString()}`}
                          {' \u00b7 '}
                          <span className="capitalize">{invite.role}</span>
                        </p>
                      </div>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => handleRevoke(invite.id)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                )
              })}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify settings page renders with team members and pending invites. Verify invite form calls sendInvite Server Action. Verify accept route creates membership and updates app_metadata.</verify>
  <done>Settings page shows team members (from tenant_memberships + auth.users) and pending invites. Invite form validates email and role, checks tier limits, sends React Email template via Resend. Revoke button marks invite as revoked. Accept route at /invite/accept handles token validation, expiry, membership creation, and app_metadata update.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Settings page accessible at /settings for admin/owner roles
- Invite form submits to sendInvite Server Action
- Invite email sent via Resend with correct accept URL
- Accept route at /invite/accept validates token and adds user to tenant
- Expired tokens rejected with user-friendly error
- Duplicate pending invites to same email prevented
- Team members listed with role badges
- Pending invites listed with revoke button
- Login page at /login?invite_token=xxx shows invite banner and passes token to loginAction
- Signup page at /signup?invite_token=xxx hides plan/company fields and passes token to signUpAction
- loginAction redirects to /invite/accept?token=xxx after successful login when invite_token present
- signUpAction skips tenant/Stripe creation and redirects to /invite/accept?token=xxx when invite_token present
</verification>

<success_criteria>
- Admin can invite a team member by email with role selection
- Invite email contains working accept link
- Accepting invite adds user to tenant with correct role
- User's app_metadata updated for immediate JWT claims
- Pending invites visible and revokable on settings page
- Tier limits checked before sending invite
- Expired invites handled gracefully
- Unauthenticated user clicking invite link is redirected to login with invite_token preserved
- After login with invite_token, user is auto-redirected to accept the invite
- New user can sign up from invite link (plan/company fields hidden), and after signup is auto-redirected to accept the invite
</success_criteria>

<output>
After completion, create `.planning/phases/05-onboarding---stripe-polish/05-04-SUMMARY.md`
</output>
