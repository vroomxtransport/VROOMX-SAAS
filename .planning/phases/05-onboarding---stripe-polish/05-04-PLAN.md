---
phase: 05-onboarding---stripe-polish
plan: 04
type: execute
wave: 3
depends_on: ["05-01", "05-02"]
files_modified:
  - src/app/actions/invites.ts
  - src/components/email/invite-email.tsx
  - src/app/(auth)/invite/accept/route.ts
  - src/app/(dashboard)/settings/page.tsx
  - src/app/(dashboard)/settings/team-section.tsx
autonomous: true

must_haves:
  truths:
    - "Admin can send an invite email to a new team member"
    - "Invite email contains accept link with token"
    - "Clicking accept link adds user to tenant with correct role"
    - "Accepted user's app_metadata is updated with tenant_id and role"
    - "Pending invites are listed on the settings page"
    - "Duplicate invite to same email in same tenant is prevented"
    - "Expired invites cannot be accepted"
  artifacts:
    - path: "src/app/actions/invites.ts"
      provides: "sendInvite and revokeInvite Server Actions"
      exports: ["sendInvite", "revokeInvite"]
    - path: "src/components/email/invite-email.tsx"
      provides: "React Email template for team invitations"
      contains: "InviteEmail"
    - path: "src/app/(auth)/invite/accept/route.ts"
      provides: "GET route handler for invite acceptance"
      exports: ["GET"]
    - path: "src/app/(dashboard)/settings/page.tsx"
      provides: "Settings page with team management section"
      contains: "TeamSection"
    - path: "src/app/(dashboard)/settings/team-section.tsx"
      provides: "Team members list and invite form component"
      contains: "TeamSection"
  key_links:
    - from: "src/app/actions/invites.ts"
      to: "src/components/email/invite-email.tsx"
      via: "Resend sends invite email using React Email template"
      pattern: "InviteEmail"
    - from: "src/app/(auth)/invite/accept/route.ts"
      to: "src/app/actions/invites.ts"
      via: "Accept route validates token and adds user to tenant"
      pattern: "tenant_memberships.*insert"
    - from: "src/app/(dashboard)/settings/team-section.tsx"
      to: "src/app/actions/invites.ts"
      via: "Invite form calls sendInvite action"
      pattern: "sendInvite"
---

<objective>
Build the complete team invite flow: send invite email, accept invite, manage pending invites on settings page.

Purpose: Requirement AUTH-6 -- team members can be invited and join a tenant with the correct role. This enables multi-user organizations.
Output: Invite Server Actions, email template, accept route, settings page with team management.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/app/actions/auth.ts
@src/components/email/invoice-email.tsx
@src/lib/resend/client.ts
@src/lib/supabase/server.ts
@src/lib/supabase/service-role.ts
@src/lib/validations/invite.ts
@src/types/index.ts
@.planning/phases/05-onboarding---stripe-polish/05-01-SUMMARY.md
@.planning/phases/05-onboarding---stripe-polish/05-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create invite Server Actions, email template, and accept route</name>
  <files>src/app/actions/invites.ts, src/components/email/invite-email.tsx, src/app/(auth)/invite/accept/route.ts</files>
  <action>
**1. Create `src/components/email/invite-email.tsx`:**

Follow the exact same pattern as `invoice-email.tsx` (React Email components, inline styles):

```typescript
import {
  Body, Container, Head, Heading, Hr, Html, Link, Preview, Section, Text,
} from '@react-email/components'

interface InviteEmailProps {
  tenantName: string
  inviterName: string
  role: string
  acceptUrl: string
}

export function InviteEmail({ tenantName, inviterName, role, acceptUrl }: InviteEmailProps) {
  return (
    <Html>
      <Head />
      <Preview>You've been invited to join {tenantName} on VroomX</Preview>
      <Body style={bodyStyle}>
        <Container style={containerStyle}>
          <Heading style={headingStyle}>Team Invitation</Heading>

          <Text style={textStyle}>
            {inviterName} has invited you to join <strong>{tenantName}</strong> on VroomX
            as a <strong>{role}</strong>.
          </Text>

          <Section style={buttonSectionStyle}>
            <Link href={acceptUrl} style={buttonStyle}>
              Accept Invitation
            </Link>
          </Section>

          <Hr style={hrStyle} />

          <Text style={footerStyle}>
            This invitation expires in 72 hours. If you didn't expect this email, you can safely ignore it.
          </Text>
        </Container>
      </Body>
    </Html>
  )
}
```

Add inline styles matching invoice-email.tsx pattern. Add button styles:
```typescript
const buttonSectionStyle: React.CSSProperties = {
  textAlign: 'center' as const,
  marginTop: '24px',
  marginBottom: '24px',
}

const buttonStyle: React.CSSProperties = {
  display: 'inline-block',
  backgroundColor: '#2563eb',
  color: '#ffffff',
  padding: '12px 24px',
  borderRadius: '6px',
  fontSize: '14px',
  fontWeight: 'bold',
  textDecoration: 'none',
}
```

Reuse bodyStyle, containerStyle, headingStyle, textStyle, hrStyle, footerStyle with same values as invoice-email.tsx.

**2. Create `src/app/actions/invites.ts`:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { resend } from '@/lib/resend/client'
import { inviteSchema } from '@/lib/validations/invite'
import { checkTierLimit } from '@/lib/tier'
import { hasMinRole } from '@/lib/tier'
import { InviteEmail } from '@/components/email/invite-email'
import { render } from '@react-email/render'
import { revalidatePath } from 'next/cache'

export async function sendInvite(data: unknown) {
  const parsed = inviteSchema.safeParse(data)
  if (!parsed.success) {
    return { error: parsed.error.flatten().fieldErrors }
  }

  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const tenantId = user.app_metadata?.tenant_id
  const userRole = user.app_metadata?.role
  if (!tenantId) return { error: 'No tenant found' }

  // Only admins and owners can invite
  if (!hasMinRole(userRole, 'admin')) {
    return { error: 'You do not have permission to invite team members' }
  }

  // Check user limit before inviting (count accepted members only)
  const tierCheck = await checkTierLimit(supabase, tenantId, 'users')
  if (!tierCheck.allowed) {
    if (tierCheck.limit === 0) {
      return { error: 'Your account is suspended. Please update your payment method.' }
    }
    return { error: `Team member limit reached (${tierCheck.current}/${tierCheck.limit}). Upgrade your plan to add more team members.` }
  }

  // Check for existing pending invite to same email in this tenant
  const admin = createServiceRoleClient()
  const { data: existingInvite } = await admin
    .from('invites')
    .select('id')
    .eq('tenant_id', tenantId)
    .eq('email', parsed.data.email)
    .eq('status', 'pending')
    .single()

  if (existingInvite) {
    return { error: 'An invite has already been sent to this email address' }
  }

  // Check if user is already a member of this tenant
  const { data: existingMember } = await admin
    .from('tenant_memberships')
    .select('id, user_id!inner(email)')
    .eq('tenant_id', tenantId)

  // Note: We can't easily join auth.users from supabase-js, so check differently:
  // Look up user by email to see if they're already a member
  const { data: existingUserData } = await admin.auth.admin.listUsers()
  const existingUser = existingUserData?.users?.find(u => u.email === parsed.data.email)
  if (existingUser) {
    const { data: membership } = await admin
      .from('tenant_memberships')
      .select('id')
      .eq('tenant_id', tenantId)
      .eq('user_id', existingUser.id)
      .single()

    if (membership) {
      return { error: 'This user is already a member of your organization' }
    }
  }

  // Create invite token (crypto.randomUUID)
  const token = crypto.randomUUID()
  const expiresAt = new Date(Date.now() + 72 * 60 * 60 * 1000) // 72 hours

  const { error: insertError } = await admin
    .from('invites')
    .insert({
      tenant_id: tenantId,
      email: parsed.data.email,
      role: parsed.data.role,
      token,
      invited_by: user.id,
      expires_at: expiresAt.toISOString(),
      status: 'pending',
    })

  if (insertError) {
    console.error('Failed to create invite:', insertError)
    return { error: 'Failed to create invite' }
  }

  // Fetch tenant name for email
  const { data: tenant } = await supabase
    .from('tenants')
    .select('name')
    .eq('id', tenantId)
    .single()

  // Send invite email via Resend with React Email template
  const acceptUrl = `${process.env.NEXT_PUBLIC_APP_URL}/invite/accept?token=${token}`
  const inviterName = user.user_metadata?.full_name || user.email || 'A team member'

  const emailHtml = await render(InviteEmail({
    tenantName: tenant?.name || 'Your team',
    inviterName,
    role: parsed.data.role,
    acceptUrl,
  }))

  try {
    await resend.emails.send({
      from: `${tenant?.name || 'VroomX'} <${process.env.RESEND_FROM_EMAIL || 'onboarding@resend.dev'}>`,
      to: [parsed.data.email],
      subject: `You've been invited to join ${tenant?.name || 'a team'} on VroomX`,
      html: emailHtml,
    })
  } catch (emailError) {
    console.error('Failed to send invite email:', emailError)
    // Don't fail the invite -- it's created in DB. User can resend.
  }

  revalidatePath('/settings')
  return { success: true }
}

export async function revokeInvite(inviteId: string) {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()
  if (!user) return { error: 'Not authenticated' }

  const userRole = user.app_metadata?.role
  if (!hasMinRole(userRole, 'admin')) {
    return { error: 'You do not have permission to revoke invites' }
  }

  const tenantId = user.app_metadata?.tenant_id
  const admin = createServiceRoleClient()

  const { error } = await admin
    .from('invites')
    .update({ status: 'revoked' })
    .eq('id', inviteId)
    .eq('tenant_id', tenantId) // Security: only revoke own tenant's invites

  if (error) {
    return { error: 'Failed to revoke invite' }
  }

  revalidatePath('/settings')
  return { success: true }
}
```

**Important notes on the existing member check:** The `listUsers` approach is heavy. For a simpler alternative, skip the full member check and let the accept route handle it (it will fail on unique constraint if user is already a member). Keep the simple duplicate pending invite check only. Remove the `listUsers` block and replace it with a comment: `// Duplicate membership is caught by unique constraint on acceptance`.

Actually, revise the approach: Remove the heavy `listUsers` call. Instead, just check for duplicate pending invites (already done) and let the accept flow handle the case where the user is already a member. This is simpler and more efficient.

**3. Create `src/app/(auth)/invite/accept/route.ts`:**

```typescript
import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { redirect } from 'next/navigation'

export async function GET(request: NextRequest) {
  const token = request.nextUrl.searchParams.get('token')

  if (!token) {
    return redirect('/login?error=' + encodeURIComponent('Invalid invite link'))
  }

  const admin = createServiceRoleClient()

  // 1. Validate invite token
  const { data: invite, error: inviteError } = await admin
    .from('invites')
    .select('*')
    .eq('token', token)
    .eq('status', 'pending')
    .single()

  if (inviteError || !invite) {
    return redirect('/login?error=' + encodeURIComponent('Invalid or expired invite'))
  }

  // Check expiry
  if (new Date(invite.expires_at) < new Date()) {
    // Mark as expired
    await admin.from('invites').update({ status: 'expired' }).eq('id', invite.id)
    return redirect('/login?error=' + encodeURIComponent('This invite has expired'))
  }

  // 2. Check if user is authenticated
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (user) {
    // User is logged in -- add to tenant directly
    try {
      // Check if already a member
      const { data: existingMembership } = await admin
        .from('tenant_memberships')
        .select('id')
        .eq('tenant_id', invite.tenant_id)
        .eq('user_id', user.id)
        .single()

      if (existingMembership) {
        // Already a member -- mark invite as accepted and redirect
        await admin.from('invites').update({ status: 'accepted', accepted_at: new Date().toISOString() }).eq('id', invite.id)
        return redirect('/dashboard')
      }

      // Add to tenant_memberships
      const { error: memberError } = await admin
        .from('tenant_memberships')
        .insert({
          tenant_id: invite.tenant_id,
          user_id: user.id,
          role: invite.role,
        })

      if (memberError) {
        console.error('Failed to add member:', memberError)
        return redirect('/dashboard?error=' + encodeURIComponent('Failed to join team'))
      }

      // Update user's app_metadata with new tenant_id and role
      // CRITICAL: This is necessary for JWT hook to include tenant info (see Pitfall 6)
      await admin.auth.admin.updateUserById(user.id, {
        app_metadata: {
          tenant_id: invite.tenant_id,
          role: invite.role,
          plan: 'trial', // Will be updated on next JWT refresh via hook
        },
      })

      // Mark invite as accepted
      await admin.from('invites').update({
        status: 'accepted',
        accepted_at: new Date().toISOString(),
      }).eq('id', invite.id)

      return redirect('/dashboard')
    } catch (err) {
      console.error('Invite acceptance error:', err)
      return redirect('/dashboard?error=' + encodeURIComponent('Failed to join team'))
    }
  }

  // 3. Not logged in -- redirect to login/signup with invite context
  // Store token in URL so after login, user can be redirected back
  return redirect(`/login?invite_token=${token}`)
}
```

**Note:** The login page already shows error messages from URL params. The `invite_token` param is stored but the login-then-accept flow is a future enhancement (Phase 7). For MVP, the accept route works when the user is already logged in. For new users, they'll see the login page with the token in the URL -- they can sign up separately and the admin can resend the invite. This is acceptable for v1.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify invite email template renders correctly. Verify accept route handles: valid token + logged in user, expired token, invalid token. Verify sendInvite checks tier limits and role permissions.</verify>
  <done>sendInvite creates invite record, sends React Email template via Resend, checks tier limits and role permissions. revokeInvite marks invite as revoked. Accept route validates token expiry, adds user to tenant_memberships, updates app_metadata, marks invite as accepted. Expired/invalid tokens redirect with error.</done>
</task>

<task type="auto">
  <name>Task 2: Create settings page with team management section</name>
  <files>src/app/(dashboard)/settings/page.tsx, src/app/(dashboard)/settings/team-section.tsx</files>
  <action>
**1. Create `src/app/(dashboard)/settings/page.tsx`:**

Server Component that fetches tenant data, team members, and pending invites. Follow the existing dashboard page pattern (server component with data fetching):

```typescript
import { createClient } from '@/lib/supabase/server'
import { createServiceRoleClient } from '@/lib/supabase/service-role'
import { redirect } from 'next/navigation'
import { TeamSection } from './team-section'
import type { TenantRole } from '@/types'

export default async function SettingsPage() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) redirect('/login')

  const tenantId = user.app_metadata?.tenant_id
  const userRole = user.app_metadata?.role as TenantRole

  if (!tenantId) redirect('/login')

  // Fetch tenant details
  const { data: tenant } = await supabase
    .from('tenants')
    .select('id, name, plan, subscription_status, stripe_customer_id')
    .eq('id', tenantId)
    .single()

  if (!tenant) redirect('/login')

  // Fetch team members (memberships + user info via service role)
  const admin = createServiceRoleClient()
  const { data: memberships } = await admin
    .from('tenant_memberships')
    .select('id, user_id, role, created_at')
    .eq('tenant_id', tenantId)
    .order('created_at', { ascending: true })

  // Fetch user details for each membership
  const { data: usersData } = await admin.auth.admin.listUsers({ perPage: 100 })
  const userMap = new Map(
    (usersData?.users || []).map(u => [u.id, { email: u.email || '', name: u.user_metadata?.full_name || '' }])
  )

  const teamMembers = (memberships || []).map(m => ({
    id: m.id,
    userId: m.user_id,
    email: userMap.get(m.user_id)?.email || 'Unknown',
    name: userMap.get(m.user_id)?.name || '',
    role: m.role as TenantRole,
    joinedAt: m.created_at,
  }))

  // Fetch pending invites
  const { data: pendingInvites } = await supabase
    .from('invites')
    .select('id, email, role, created_at, expires_at')
    .eq('tenant_id', tenantId)
    .eq('status', 'pending')
    .order('created_at', { ascending: false })

  return (
    <div className="space-y-6">
      <div>
        <h1 className="text-3xl font-bold text-gray-900">Settings</h1>
        <p className="mt-2 text-gray-600">Manage your organization and team.</p>
      </div>

      {(userRole === 'owner' || userRole === 'admin') && (
        <TeamSection
          teamMembers={teamMembers}
          pendingInvites={pendingInvites || []}
          currentUserId={user.id}
          userRole={userRole}
          plan={tenant.plan}
        />
      )}
    </div>
  )
}
```

**2. Create `src/app/(dashboard)/settings/team-section.tsx`:**

Client component for team management (invite form + member list + pending invites):

```typescript
'use client'

import { useState } from 'react'
import { useRouter } from 'next/navigation'
import { sendInvite, revokeInvite } from '@/app/actions/invites'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Input } from '@/components/ui/input'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { Badge } from '@/components/ui/badge'
import { toast } from 'sonner'
import { UserPlus, X, Mail, Clock } from 'lucide-react'
import type { TenantRole } from '@/types'
import { INVITABLE_ROLES } from '@/types'

interface TeamMember {
  id: string
  userId: string
  email: string
  name: string
  role: TenantRole
  joinedAt: string
}

interface PendingInvite {
  id: string
  email: string
  role: string
  created_at: string
  expires_at: string
}

interface TeamSectionProps {
  teamMembers: TeamMember[]
  pendingInvites: PendingInvite[]
  currentUserId: string
  userRole: TenantRole
  plan: string
}

export function TeamSection({
  teamMembers,
  pendingInvites,
  currentUserId,
  userRole,
  plan,
}: TeamSectionProps) {
  const router = useRouter()
  const [email, setEmail] = useState('')
  const [role, setRole] = useState<string>('dispatcher')
  const [sending, setSending] = useState(false)

  async function handleInvite(e: React.FormEvent) {
    e.preventDefault()
    if (!email) return

    setSending(true)
    const result = await sendInvite({ email, role })
    setSending(false)

    if (result?.error) {
      const errorMsg = typeof result.error === 'string' ? result.error : 'Invalid input'
      toast.error(errorMsg)
      return
    }

    toast.success(`Invite sent to ${email}`)
    setEmail('')
    router.refresh()
  }

  async function handleRevoke(inviteId: string) {
    const result = await revokeInvite(inviteId)
    if (result?.error) {
      toast.error(result.error)
      return
    }
    toast.success('Invite revoked')
    router.refresh()
  }

  return (
    <div className="space-y-6">
      {/* Invite form */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <UserPlus className="h-5 w-5" />
            Invite Team Member
          </CardTitle>
          <CardDescription>
            Send an email invitation to add someone to your organization.
          </CardDescription>
        </CardHeader>
        <CardContent>
          <form onSubmit={handleInvite} className="flex gap-3">
            <Input
              type="email"
              placeholder="colleague@example.com"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="flex-1"
              required
            />
            <Select value={role} onValueChange={setRole}>
              <SelectTrigger className="w-[140px]">
                <SelectValue />
              </SelectTrigger>
              <SelectContent>
                {INVITABLE_ROLES.map((r) => (
                  <SelectItem key={r} value={r} className="capitalize">
                    {r}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
            <Button type="submit" disabled={sending}>
              {sending ? 'Sending...' : 'Send Invite'}
            </Button>
          </form>
        </CardContent>
      </Card>

      {/* Team members */}
      <Card>
        <CardHeader>
          <CardTitle>Team Members ({teamMembers.length})</CardTitle>
          <CardDescription>People who have access to your organization.</CardDescription>
        </CardHeader>
        <CardContent>
          <div className="divide-y">
            {teamMembers.map((member) => (
              <div key={member.id} className="flex items-center justify-between py-3">
                <div className="flex items-center gap-3">
                  <div className="flex h-8 w-8 items-center justify-center rounded-full bg-gray-100 text-sm font-medium text-gray-600">
                    {(member.name || member.email)[0]?.toUpperCase()}
                  </div>
                  <div>
                    <p className="text-sm font-medium text-gray-900">
                      {member.name || member.email}
                      {member.userId === currentUserId && (
                        <span className="ml-2 text-xs text-gray-500">(you)</span>
                      )}
                    </p>
                    <p className="text-xs text-gray-500">{member.email}</p>
                  </div>
                </div>
                <Badge variant="secondary" className="capitalize">
                  {member.role}
                </Badge>
              </div>
            ))}
          </div>
        </CardContent>
      </Card>

      {/* Pending invites */}
      {pendingInvites.length > 0 && (
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Mail className="h-5 w-5" />
              Pending Invites ({pendingInvites.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="divide-y">
              {pendingInvites.map((invite) => {
                const isExpired = new Date(invite.expires_at) < new Date()
                return (
                  <div key={invite.id} className="flex items-center justify-between py-3">
                    <div className="flex items-center gap-3">
                      <Clock className="h-4 w-4 text-gray-400" />
                      <div>
                        <p className="text-sm font-medium text-gray-900">{invite.email}</p>
                        <p className="text-xs text-gray-500">
                          {isExpired ? 'Expired' : `Expires ${new Date(invite.expires_at).toLocaleDateString()}`}
                          {' \u00b7 '}
                          <span className="capitalize">{invite.role}</span>
                        </p>
                      </div>
                    </div>
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => handleRevoke(invite.id)}
                    >
                      <X className="h-4 w-4" />
                    </Button>
                  </div>
                )
              })}
            </div>
          </CardContent>
        </Card>
      )}
    </div>
  )
}
```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify settings page renders with team members and pending invites. Verify invite form calls sendInvite Server Action. Verify accept route creates membership and updates app_metadata.</verify>
  <done>Settings page shows team members (from tenant_memberships + auth.users) and pending invites. Invite form validates email and role, checks tier limits, sends React Email template via Resend. Revoke button marks invite as revoked. Accept route at /invite/accept handles token validation, expiry, membership creation, and app_metadata update.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Settings page accessible at /settings for admin/owner roles
- Invite form submits to sendInvite Server Action
- Invite email sent via Resend with correct accept URL
- Accept route at /invite/accept validates token and adds user to tenant
- Expired tokens rejected with user-friendly error
- Duplicate pending invites to same email prevented
- Team members listed with role badges
- Pending invites listed with revoke button
</verification>

<success_criteria>
- Admin can invite a team member by email with role selection
- Invite email contains working accept link
- Accepting invite adds user to tenant with correct role
- User's app_metadata updated for immediate JWT claims
- Pending invites visible and revokable on settings page
- Tier limits checked before sending invite
- Expired invites handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/05-onboarding---stripe-polish/05-04-SUMMARY.md`
</output>
