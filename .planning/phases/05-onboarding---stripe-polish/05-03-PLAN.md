---
phase: 05-onboarding---stripe-polish
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/lib/stripe/webhook-handlers.ts
  - src/app/api/webhooks/stripe/route.ts
  - src/app/actions/billing.ts
  - src/lib/stripe/billing-portal.ts
autonomous: true

must_haves:
  truths:
    - "invoice.paid webhook clears grace period and suspension on the tenant"
    - "invoice.payment_failed webhook sets grace_period_ends_at to 14 days from now"
    - "Billing portal session is created via Server Action and redirects to Stripe"
    - "Duplicate webhook events are still handled by idempotency check"
    - "Webhook handlers extend the existing switch statement, not replace it"
  artifacts:
    - path: "src/lib/stripe/webhook-handlers.ts"
      provides: "handleInvoicePaid and handlePaymentFailedWithGrace functions"
      exports: ["handleInvoicePaid", "handlePaymentFailedWithGrace"]
    - path: "src/app/api/webhooks/stripe/route.ts"
      provides: "Extended switch with invoice.paid case"
      contains: "invoice.paid"
    - path: "src/app/actions/billing.ts"
      provides: "createBillingPortalSession Server Action"
      exports: ["createBillingPortalSession"]
    - path: "src/lib/stripe/billing-portal.ts"
      provides: "Helper for creating Stripe billing portal sessions"
      contains: "billingPortal.sessions.create"
  key_links:
    - from: "src/app/api/webhooks/stripe/route.ts"
      to: "src/lib/stripe/webhook-handlers.ts"
      via: "import and call in switch statement"
      pattern: "handleInvoicePaid|handlePaymentFailedWithGrace"
    - from: "src/app/actions/billing.ts"
      to: "src/lib/stripe/billing-portal.ts"
      via: "import createPortalSession"
      pattern: "createPortalSession"
---

<objective>
Extend Stripe webhook handling with dunning flow (grace period on payment failure, clearing on payment success) and add Stripe Billing Portal integration via Server Action.

Purpose: Production-ready Stripe integration: failed payments trigger a 14-day grace period instead of immediate lockout, successful payments clear any grace/suspension state, and users can self-service manage their subscription via Stripe's Billing Portal.
Output: Extended webhook handlers, new billing portal Server Action and helper.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md
@src/lib/stripe/webhook-handlers.ts
@src/app/api/webhooks/stripe/route.ts
@src/lib/stripe/config.ts
@src/app/actions/auth.ts
@.planning/phases/05-onboarding---stripe-polish/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend webhook handlers with dunning flow (invoice.paid + payment_failed grace period)</name>
  <files>src/lib/stripe/webhook-handlers.ts, src/app/api/webhooks/stripe/route.ts</files>
  <action>
**1. Add two new handlers to `src/lib/stripe/webhook-handlers.ts`:**

Add these AFTER the existing `handlePaymentFailed` function. Do NOT modify or remove any existing handlers.

```typescript
/**
 * Handle successful invoice payment - clears grace period and suspension.
 * Fires on every successful payment (initial, renewal, manual retry).
 */
export async function handleInvoicePaid(invoice: Stripe.Invoice) {
  const supabase = createServiceRoleClient()

  const subscription = (invoice as any).subscription
  if (!subscription) return

  const subscriptionId = typeof subscription === 'string'
    ? subscription
    : subscription.id

  if (!subscriptionId) return

  const { data: tenant } = await supabase
    .from('tenants')
    .select('id')
    .eq('stripe_subscription_id', subscriptionId)
    .single()

  if (!tenant) {
    console.error('invoice.paid: no tenant found for subscription', subscriptionId)
    return
  }

  // Clear grace period and suspension on successful payment
  const { error } = await supabase
    .from('tenants')
    .update({
      subscription_status: 'active',
      grace_period_ends_at: null,
      is_suspended: false,
    })
    .eq('id', tenant.id)

  if (error) {
    console.error('invoice.paid: failed to update tenant', error)
    throw error
  }
}

/**
 * Handle payment failure with grace period.
 * Replaces simple status update with grace period logic.
 * Sets grace_period_ends_at to 14 days from now (only if not already in grace).
 */
export async function handlePaymentFailedWithGrace(invoice: Stripe.Invoice) {
  const supabase = createServiceRoleClient()

  const subscription = (invoice as any).subscription
  if (!subscription) return

  const subscriptionId = typeof subscription === 'string'
    ? subscription
    : subscription.id

  if (!subscriptionId) return

  const { data: tenant } = await supabase
    .from('tenants')
    .select('id, grace_period_ends_at')
    .eq('stripe_subscription_id', subscriptionId)
    .single()

  if (!tenant) {
    console.error('payment_failed_grace: no tenant found for subscription', subscriptionId)
    return
  }

  // Build update: always set past_due, only set grace period if not already in one
  const updates: Record<string, any> = {
    subscription_status: 'past_due',
  }

  if (!tenant.grace_period_ends_at) {
    updates.grace_period_ends_at = new Date(
      Date.now() + 14 * 24 * 60 * 60 * 1000  // 14 days
    ).toISOString()
  }

  const { error } = await supabase
    .from('tenants')
    .update(updates)
    .eq('id', tenant.id)

  if (error) {
    console.error('payment_failed_grace: failed to update tenant', error)
    throw error
  }
}
```

**2. Update the webhook route `src/app/api/webhooks/stripe/route.ts`:**

Add `handleInvoicePaid` and `handlePaymentFailedWithGrace` to the imports:

```typescript
import {
  handleCheckoutCompleted,
  handleSubscriptionUpdated,
  handleSubscriptionDeleted,
  handlePaymentFailed,
  handleInvoicePaid,
  handlePaymentFailedWithGrace,
} from '@/lib/stripe/webhook-handlers'
```

In the switch statement, ADD a new case for `invoice.paid` and REPLACE the `invoice.payment_failed` handler:

```typescript
case 'invoice.paid':
  await handleInvoicePaid(event.data.object as Stripe.Invoice)
  break
case 'invoice.payment_failed':
  await handlePaymentFailedWithGrace(event.data.object as Stripe.Invoice)
  break
```

**Important:** The `invoice.payment_failed` case REPLACES the old handler call (`handlePaymentFailed` -> `handlePaymentFailedWithGrace`). The old `handlePaymentFailed` function stays in webhook-handlers.ts for reference but is no longer called from the route. The `invoice.paid` case is NEW.

Do NOT modify the idempotency check, signature verification, or event marking logic. Only change the switch cases.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the switch statement has the new cases. Verify existing handlers (checkout.session.completed, customer.subscription.updated, customer.subscription.deleted) are unchanged.</verify>
  <done>Webhook route handles `invoice.paid` (clears grace period + suspension) and `invoice.payment_failed` (sets 14-day grace period). Old handlePaymentFailed preserved but route uses handlePaymentFailedWithGrace. Idempotency and signature verification unchanged.</done>
</task>

<task type="auto">
  <name>Task 2: Create Stripe Billing Portal Server Action and helper</name>
  <files>src/lib/stripe/billing-portal.ts, src/app/actions/billing.ts</files>
  <action>
**1. Create `src/lib/stripe/billing-portal.ts`:**

```typescript
import { stripe } from './config'

/**
 * Creates a Stripe Billing Portal session for the given customer.
 * Returns the portal URL for redirect.
 */
export async function createPortalSession(
  stripeCustomerId: string,
  returnUrl: string
): Promise<string> {
  const session = await stripe.billingPortal.sessions.create({
    customer: stripeCustomerId,
    return_url: returnUrl,
  })
  return session.url
}
```

**2. Create `src/app/actions/billing.ts`:**

```typescript
'use server'

import { createClient } from '@/lib/supabase/server'
import { redirect } from 'next/navigation'
import { createPortalSession } from '@/lib/stripe/billing-portal'

/**
 * Creates a Stripe Billing Portal session and redirects the user.
 * Used from Settings page "Manage Subscription" button.
 */
export async function createBillingPortalSession() {
  const supabase = await createClient()
  const { data: { user } } = await supabase.auth.getUser()

  if (!user) {
    return { error: 'Not authenticated' }
  }

  const tenantId = user.app_metadata?.tenant_id
  if (!tenantId) {
    return { error: 'No tenant found' }
  }

  // Fetch stripe_customer_id from tenant
  const { data: tenant } = await supabase
    .from('tenants')
    .select('stripe_customer_id')
    .eq('id', tenantId)
    .single()

  if (!tenant?.stripe_customer_id) {
    return { error: 'No billing account found. Please contact support.' }
  }

  const returnUrl = `${process.env.NEXT_PUBLIC_APP_URL}/settings`

  try {
    const portalUrl = await createPortalSession(tenant.stripe_customer_id, returnUrl)
    redirect(portalUrl)
  } catch (error) {
    // redirect() throws a special error that must be re-thrown
    if ((error as any)?.digest?.startsWith('NEXT_REDIRECT')) {
      throw error
    }
    console.error('Failed to create billing portal session:', error)
    return { error: 'Failed to open billing portal. Please try again.' }
  }
}
```

**Note on redirect pattern:** Next.js `redirect()` throws a special error internally. The try/catch must re-throw redirect errors. This is a known Next.js pattern -- check if the error is a redirect by checking `error.digest` starting with `NEXT_REDIRECT`.
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify `createBillingPortalSession` is a valid Server Action (has 'use server' directive). Verify `createPortalSession` uses the lazy-loaded stripe client from config.ts. Verify redirect error is properly re-thrown.</verify>
  <done>Billing portal helper creates Stripe portal session via `billingPortal.sessions.create`. Server Action fetches tenant's stripe_customer_id, creates session, and redirects. Redirect error properly handled in try/catch.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes
- Webhook route switch has: checkout.session.completed, customer.subscription.updated, customer.subscription.deleted, invoice.paid, invoice.payment_failed
- `handleInvoicePaid` clears grace_period_ends_at and is_suspended
- `handlePaymentFailedWithGrace` sets grace_period_ends_at only if not already set
- `createBillingPortalSession` Server Action exists with proper auth checks
- Billing portal helper uses the existing lazy-loaded stripe client
</verification>

<success_criteria>
- Failed payments trigger 14-day grace period, not immediate lockout
- Successful payments clear grace period and suspension
- Second payment failure during grace period does NOT reset the grace timer
- Billing Portal Server Action creates session and redirects to Stripe
- All existing webhook handlers remain functional
- Idempotency check still prevents duplicate processing
</success_criteria>

<output>
After completion, create `.planning/phases/05-onboarding---stripe-polish/05-03-SUMMARY.md`
</output>
