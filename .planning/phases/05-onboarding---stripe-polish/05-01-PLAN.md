---
phase: 05-onboarding---stripe-polish
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/db/schema.ts
  - supabase/migrations/00005_phase5_invites_tier_enforcement.sql
  - src/types/index.ts
  - src/lib/validations/invite.ts
autonomous: true

must_haves:
  truths:
    - "Invites table exists with token, email, role, tenant_id, status, expiry columns"
    - "Tenants table has grace_period_ends_at and is_suspended columns for dunning"
    - "Tenants table has onboarding_completed_at for wizard tracking"
    - "InviteStatus type and const array are exported from types"
    - "Invite Zod schema validates email, role, and token"
  artifacts:
    - path: "supabase/migrations/00005_phase5_invites_tier_enforcement.sql"
      provides: "SQL migration for invites table, tenant columns, DB triggers for tier enforcement, RLS"
      contains: "CREATE TABLE public.invites"
    - path: "src/db/schema.ts"
      provides: "Drizzle schema for invites table and updated tenants columns"
      contains: "invites"
    - path: "src/types/index.ts"
      provides: "InviteStatus type and INVITE_STATUSES const array"
      contains: "InviteStatus"
    - path: "src/lib/validations/invite.ts"
      provides: "Zod validation schema for invite creation"
      contains: "inviteSchema"
  key_links:
    - from: "src/db/schema.ts"
      to: "supabase/migrations/00005_phase5_invites_tier_enforcement.sql"
      via: "Drizzle schema mirrors SQL migration tables"
      pattern: "invites.*pgTable"
---

<objective>
Create the database foundation for Phase 5: invites table, tenant dunning columns, tier enforcement DB triggers, and associated types/validations.

Purpose: All Phase 5 features (invites, billing portal, dunning, tier enforcement, onboarding) depend on new DB columns and tables. This must land first.
Output: SQL migration, Drizzle schema updates, TypeScript types, Zod validation for invites.
</objective>

<execution_context>
@/Users/reepsy/.claude/get-shit-done/workflows/execute-plan.md
@/Users/reepsy/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@src/db/schema.ts
@src/types/index.ts
@supabase/migrations/
</context>

<tasks>

<task type="auto">
  <name>Task 1: SQL migration for invites table, tenant columns, and tier enforcement triggers</name>
  <files>supabase/migrations/00005_phase5_invites_tier_enforcement.sql</files>
  <action>
Create a new SQL migration file with the following:

**1. Add columns to tenants table:**
```sql
ALTER TABLE public.tenants
  ADD COLUMN IF NOT EXISTS grace_period_ends_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS is_suspended BOOLEAN NOT NULL DEFAULT false,
  ADD COLUMN IF NOT EXISTS onboarding_completed_at TIMESTAMPTZ;
```

**2. Create invites table:**
```sql
CREATE TABLE public.invites (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL REFERENCES public.tenants(id) ON DELETE CASCADE,
  email TEXT NOT NULL,
  role TEXT NOT NULL DEFAULT 'dispatcher',
  token UUID NOT NULL DEFAULT gen_random_uuid(),
  invited_by UUID NOT NULL,
  status TEXT NOT NULL DEFAULT 'pending',
  expires_at TIMESTAMPTZ NOT NULL,
  accepted_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);
```
- Add unique constraint on token: `ALTER TABLE public.invites ADD CONSTRAINT invites_token_unique UNIQUE (token);`
- Add indexes: `idx_invites_tenant_id` on tenant_id, `idx_invites_token` on token, `idx_invites_email_tenant` on (tenant_id, email)
- Add `handle_updated_at` trigger (same pattern as other tables)

**3. RLS policies on invites:**
- Enable RLS: `ALTER TABLE public.invites ENABLE ROW LEVEL SECURITY;`
- SELECT policy: tenant members can see their tenant's invites (same `get_tenant_id()` pattern)
- INSERT policy: none (service role only for creation, to avoid bypass)
- UPDATE policy: none (service role only)
- DELETE policy: none (service role only)

Actually, since invites are managed via Server Actions that use `createClient()` (not service role), and the user creating the invite is authenticated with a JWT containing tenant_id, we need:
- SELECT: `tenant_id = (SELECT (current_setting('request.jwt.claims', true)::jsonb -> 'app_metadata' ->> 'tenant_id')::uuid)` -- standard RLS pattern
- INSERT: same tenant_id check -- admins/owners can create invites
- No UPDATE/DELETE for authenticated role (service role handles acceptance)

**4. Tier enforcement triggers (SECURITY DEFINER):**

```sql
-- Truck limit enforcement
CREATE OR REPLACE FUNCTION public.enforce_truck_limit()
RETURNS TRIGGER AS $$
DECLARE
  current_count INTEGER;
  tenant_plan TEXT;
  max_trucks INTEGER;
BEGIN
  SELECT plan INTO tenant_plan FROM public.tenants WHERE id = NEW.tenant_id;

  max_trucks := CASE tenant_plan
    WHEN 'starter' THEN 5
    WHEN 'pro' THEN 20
    WHEN 'enterprise' THEN 2147483647
    WHEN 'trial' THEN 5  -- trial uses starter limits
    ELSE 5
  END;

  SELECT COUNT(*) INTO current_count FROM public.trucks WHERE tenant_id = NEW.tenant_id;

  IF current_count >= max_trucks THEN
    RAISE EXCEPTION 'Truck limit reached for your plan (% of %). Please upgrade.', current_count, max_trucks;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER check_truck_limit
  BEFORE INSERT ON public.trucks
  FOR EACH ROW EXECUTE FUNCTION public.enforce_truck_limit();
```

```sql
-- User/member limit enforcement
CREATE OR REPLACE FUNCTION public.enforce_user_limit()
RETURNS TRIGGER AS $$
DECLARE
  current_count INTEGER;
  tenant_plan TEXT;
  max_users INTEGER;
BEGIN
  SELECT plan INTO tenant_plan FROM public.tenants WHERE id = NEW.tenant_id;

  max_users := CASE tenant_plan
    WHEN 'starter' THEN 3
    WHEN 'pro' THEN 10
    WHEN 'enterprise' THEN 2147483647
    WHEN 'trial' THEN 3  -- trial uses starter limits
    ELSE 3
  END;

  SELECT COUNT(*) INTO current_count FROM public.tenant_memberships WHERE tenant_id = NEW.tenant_id;

  IF current_count >= max_users THEN
    RAISE EXCEPTION 'User limit reached for your plan (% of %). Please upgrade.', current_count, max_users;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER check_user_limit
  BEFORE INSERT ON public.tenant_memberships
  FOR EACH ROW EXECUTE FUNCTION public.enforce_user_limit();
```

**5. Grant permissions:**
- Grant SELECT, INSERT on invites to authenticated role
- Grant all on invites to service_role (for acceptance flow)
  </action>
  <verify>Review migration file for syntax. Run `npx supabase db push` or verify via Supabase dashboard that migration applies cleanly. Check that invites table exists with correct columns and RLS. Check that tenant columns added. Check that triggers exist on trucks and tenant_memberships.</verify>
  <done>SQL migration creates invites table with token/email/role/status/expiry, adds grace_period_ends_at/is_suspended/onboarding_completed_at to tenants, creates tier enforcement triggers on trucks and tenant_memberships, and applies RLS policies to invites.</done>
</task>

<task type="auto">
  <name>Task 2: Drizzle schema, types, and Zod validation for Phase 5</name>
  <files>src/db/schema.ts, src/types/index.ts, src/lib/validations/invite.ts</files>
  <action>
**1. Update `src/db/schema.ts`:**

Add new columns to the existing `tenants` table definition:
```typescript
// Add to tenants table (after existing fields, before createdAt):
gracePeriodEndsAt: timestamp('grace_period_ends_at', { withTimezone: true }),
isSuspended: boolean('is_suspended').notNull().default(false),
onboardingCompletedAt: timestamp('onboarding_completed_at', { withTimezone: true }),
```
Note: Import `boolean` from `drizzle-orm/pg-core` if not already imported.

Add a new Phase 5 section after the Phase 4 tables:

```typescript
// ============================================================================
// Phase 5 Enums
// ============================================================================

export const inviteStatusEnum = pgEnum('invite_status', ['pending', 'accepted', 'expired', 'revoked'])

// ============================================================================
// Phase 5 Tables: Onboarding + Stripe Polish
// ============================================================================

/**
 * Invites Table
 * Team member invitations with token-based acceptance.
 */
export const invites = pgTable('invites', {
  id: uuid('id').primaryKey().defaultRandom(),
  tenantId: uuid('tenant_id').notNull().references(() => tenants.id, { onDelete: 'cascade' }),
  email: text('email').notNull(),
  role: text('role').notNull().default('dispatcher'),
  token: uuid('token').notNull().defaultRandom(),
  invitedBy: uuid('invited_by').notNull(),
  status: text('status').notNull().default('pending'),
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
  acceptedAt: timestamp('accepted_at', { withTimezone: true }),
  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
  updatedAt: timestamp('updated_at', { withTimezone: true }).notNull().defaultNow(),
}, (table) => [
  unique('invites_token_unique').on(table.token),
  index('idx_invites_tenant_id').on(table.tenantId),
  index('idx_invites_token').on(table.token),
  index('idx_invites_email_tenant').on(table.tenantId, table.email),
])
```

Add type exports at the bottom:
```typescript
// Phase 5
export type Invite = typeof invites.$inferSelect
export type NewInvite = typeof invites.$inferInsert
```

**2. Update `src/types/index.ts`:**

Add in the Phase 1 section (after SubscriptionStatus):
```typescript
// Invite status
export type InviteStatus = 'pending' | 'accepted' | 'expired' | 'revoked'

export const INVITE_STATUSES: readonly InviteStatus[] = [
  'pending', 'accepted', 'expired', 'revoked',
] as const
```

Also add invite-related types near the tenant roles:
```typescript
// Invitable roles (owner cannot be invited, must be the creator)
export type InvitableRole = 'admin' | 'dispatcher' | 'viewer'

export const INVITABLE_ROLES: readonly InvitableRole[] = [
  'admin', 'dispatcher', 'viewer',
] as const
```

**3. Create `src/lib/validations/invite.ts`:**

```typescript
import { z } from 'zod'

export const inviteSchema = z.object({
  email: z.string().email('Invalid email address'),
  role: z.enum(['admin', 'dispatcher', 'viewer']),
})

export type InviteInput = z.input<typeof inviteSchema>
```
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify that the Drizzle schema compiles and types are correctly exported. Check that `inviteSchema` Zod validation correctly rejects invalid emails and roles not in the enum.</verify>
  <done>Drizzle schema has invites table and updated tenants columns. Types include InviteStatus, InvitableRole with const arrays. Zod invite schema validates email and role. All TypeScript compiles cleanly.</done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- SQL migration file exists and is syntactically valid
- `invites` table definition in Drizzle schema matches SQL migration
- `tenants` table in Drizzle schema includes grace_period_ends_at, is_suspended, onboarding_completed_at
- `InviteStatus` and `InvitableRole` types exported from `@/types`
- `inviteSchema` Zod validation exported from `@/lib/validations/invite`
- DB triggers `enforce_truck_limit` and `enforce_user_limit` defined in migration
</verification>

<success_criteria>
- All new DB objects (invites table, tenant columns, triggers, RLS) are defined in migration
- Drizzle schema mirrors the SQL migration exactly
- TypeScript types and Zod validations compile without errors
- No existing functionality broken (all prior tests still pass)
</success_criteria>

<output>
After completion, create `.planning/phases/05-onboarding---stripe-polish/05-01-SUMMARY.md`
</output>
